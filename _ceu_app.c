/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "test.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_INTS
#define CEU_EXTS
#define CEU_ORGS
#define CEU_RET
#define CEU_GOTO
#define CEU_CLEAR
#define CEU_IFCS
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s8 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 3

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#define CEU_IN__NONE 0
#define CEU_IN__STK 255
#define CEU_IN__ORG 254
#define CEU_IN__ORG_PSED 253
#define CEU_IN__INIT 252
#define CEU_IN__CLEAR 251
#define CEU_IN__WCLOCK 250
#define CEU_IN__ASYNC 249
#define CEU_IN__THREAD 248
#define CEU_IN_START 247
#define CEU_IN_X_DONE 246
#define CEU_IN_Y_DONE 245
#define CEU_IN_TICK 244
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_assert
#define CEU_FUN_move_y
#define CEU_FUN_cancel_x
#define CEU_FUN_cancel_y
#define CEU_FUN_move_x
#define CEU_FUN_printf
#define CEU_FUN_y
#define CEU_FUN_x
   /* CEU_FUN_ */


/* class definitions */
/*
// TODO: host language to have access to classes
=== CLSS_DEFS ===
*/

#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

/* TODO: #ifdef CEU_INTS: seqno, stki, CEU_STK */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_OS
#ifdef __AVR
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <assert.h>
#endif

#if defined(CEU_OS) || defined(CEU_DEBUG)
#include <stdlib.h>     /* malloc/free, exit */
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic (lua_State* lua) {
#ifdef CEU_DEBUG
    fprintf(stderr, "LUA_ATPANIC: %s\n",
            lua_tostring(lua,-1));
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS)
void* ceu_sys_malloc (size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (_ceu_dyns_ >= CEU_MAX_DYNS)
        return NULL;
    _ceu_dyns_++;           /* assumes no malloc fails */
#endif
#endif
    return malloc(size);
}

void ceu_sys_free (void* ptr) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (ptr != NULL)
        _ceu_dyns_--;
#endif
#endif
    free(ptr);
}
#endif

/**********************************************************************/

/* TODO: ifndef CEU_OS? */
int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

/* TODO: CEU_OS */
#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnk;
    lnk[0].nxt = (tceu_org*) &lnk[1];
    lnk[1].prv = (tceu_org*) &lnk[0];
    lnk[1].nxt =  org;
    lnk[1].n   =  0;    /* marks end of linked list */
    lnk[1].lnk =  idx+1;
}

int ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org) {
    /* hold current blk trail: set to my continuation */
    _ceu_go->trl->evt = CEU_IN__STK;
    _ceu_go->trl->lbl = lbl_cnt;
    _ceu_go->trl->stk = _ceu_go->stki;

    _ceu_go->stk[_ceu_go->stki  ].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _ceu_go->stk[_ceu_go->stki  ].evto = _ceu_go->evto;
#endif
#endif
    _ceu_go->stk[_ceu_go->stki++].evt  = _ceu_go->evt;

    /* switch to ORG */

    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl_org;
    org->trls[0].stk = _ceu_go->stki;

    _ceu_go->org  = org;
#ifdef CEU_CLEAR
    _ceu_go->stop = &_ceu_go->org->trls[_ceu_go->org->n]; /* don't follow the up link */
#endif
    return RET_ORG;
}

#endif

void ceu_sys_org (tceu_org* org, int n, int lbl, int seqno,
#ifdef CEU_NEWS
                  int isDyn,
#endif
                  tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS)
    org->n = n;
    org->isAlive = 1;
#endif
#ifdef CEU_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_sys_org(a,b,c,d,e,f) ceu_sys_org(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_tmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min > t) {
        app->wclk_min = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late_;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp_ || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min_ > t) {
        app->wclk_min_ = t;
#ifdef ceu_out_wclock_set_
        ceu_out_wclock_set_(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_CLEAR
/* TODO: CEU_OS map (ceu_out_* )*/
int ceu_sys_clear (tceu_go* go, int start, void* stop) {
    go->stk[go->stki  ].evtp = go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    go->stk[go->stki  ].evto = go->evto;
#endif
#endif
    go->stk[go->stki++].evt  = go->evt;
    go->trl  = &go->org->trls[start];
    go->stop = stop;
    go->evt = CEU_IN__CLEAR;
    return RET_TRL;
}
#endif

/* TODO: ifndef CEU_OS? */
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */

void ceu_sys_go (tceu_app* app, int evt, tceu_evtp evtp)
{
    tceu_go go;

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            if (app->wclk_min <= evtp.dt) {
                app->wclk_late = evtp.dt - app->wclk_min;
            }
            app->wclk_min_tmp = app->wclk_min;
            app->wclk_min     = CEU_WCLOCK_INACTIVE;
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            if (app->wclk_min_ <= evtp.dt) {
                app->wclk_late_ = evtp.dt - app->wclk_min_;
            }
            app->wclk_min_tmp_ = app->wclk_min_;
            app->wclk_min_     = CEU_WCLOCK_INACTIVE;
            break;
#endif
#endif
    }

    go.evt  = evt;
    go.evtp = evtp;
    go.stki = 0;
#ifdef CEU_CLEAR
    go.stop = NULL;     /* traverse all (don't stop) */
#endif

#ifdef CEU_NEWS
    tceu_org* lst_free = NULL;  /* "to free" list (only on reaction end) */
#endif

    app->seqno++;

    for (;;)    /* STACK */
    {
#ifdef CEU_DEBUG
        assert(go.stki < 32000);
#endif
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        go.org = app->data;    /* on pop(), always restart */
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_GO_CALL_ORG_:
#endif
        /* restart from org->trls[0] */
        go.trl = &go.org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_GO_CALL_TRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#if defined(CEU_ORGS) || defined(CEU_OS)
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", app->seqno,
                go.evt, go.stki, go.org, go.org->n, go.org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", app->seqno,
                go.evt, go.stki, CEU_NTRAILS);
#endif
#endif

        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
#ifdef CEU_CLEAR
            if (go.trl == go.stop) {    /* bounded trail traversal? */
                go.stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* go.org has been traversed to the end? */
            if (go.trl ==
                &go.org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS)
                    go.org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (go.org == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = go.org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (go.org->n == 0) ?
                                         ((tceu_org_lnk*)go.org)->lnk : 0
                                      ];

                    /* org has been traversed and *CLEARED* to the end? */
                    if (go.evt == CEU_IN__CLEAR) {

#ifdef CEU_ORGS_WATCHING
                        /* TODO: stack will overflow!!! T[9999] */
                        /* emit this.ok */
                        /*go.stk[go.stki].evtp = ?*/
                        go.stk[go.stki].evto = go.org;
                        go.stk[go.stki].evt  = 1;   /* TODO: 1==_ok */
                        go.stki++;
#endif

#ifdef CEU_NEWS
                        if ( go.org->n != 0 /* TODO: avoids LNKs (must be before isDyn */
                        &&   go.org->isDyn ) {
                            /* re-link PRV <-> NXT */
                            go.org->prv->nxt = go.org->nxt;
                            go.org->nxt->prv = go.org->prv;

                            /* Should be freed if (malloc'ed) or
                             *                    (pool still on scope):
                             * - malloc'ed:     (org->pool==NULL)
                             * - pool on scope: (!org->isAlive)
                             */
/* TODO: what if both happens at the same time (body and pool terminate?) */
#ifdef CEU_NEWS_POOL
                            if (!go.org->isAlive
#ifdef CEU_NEWS_MALLOC
                            || go.org->pool == NULL
#endif
                            )
#else
                            /* malloc'ed for sure, no if required */
#endif
                            {
                                tceu_org* nxt = lst_free;
                                go.org->nxt_free = NULL;    /* no next element */
                                if (lst_free == NULL) {
                                    lst_free = go.org;      /* new first element */
                                } else {
                                    while (nxt->nxt_free != NULL) {
                                        nxt = nxt->nxt_free; /* find last element */
                                    }
                                    nxt->nxt_free = go.org;  /* put after that */
                                }
                            }
                            go.org->isAlive = 0;

                            /* explicit free(me) or end of spawn */
                            if (go.stop == go.org)
                                break;  /* pop stack */
                        }
#else
                        go.org->isAlive = 0;
#endif  /* CEU_NEWS */
                    }

                    go.org = _org;
                    go.trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, go.org go.trl);*/
                    goto _CEU_GO_CALL_TRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (go.trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=%p->%p\n",
                    go.trl, go.trl->evt,
                    &go.trl->lnks[0], &go.trl->lnks[1]);
else
#endif
    fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    go.trl, go.trl->evt, go.trl->seqno, go.trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (go.trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (go.trl->evt==CEU_IN__ORG_PSED && go.evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    go.org = go.trl->lnks[0].nxt;   /* jump FST */
                    if (go.evt == CEU_IN__CLEAR) {
                        go.trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_GO_CALL_ORG_;
                }
#endif /* CEU_ORGS */

                switch (go.evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (go.trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_GO_;
                        go.trl->evt = CEU_IN__NONE;
                        goto _CEU_GO_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (go.trl->evt==CEU_IN__STK && go.trl->stk==go.stki)
                ||
                    (go.trl->evt==go.evt && go.trl->seqno!=app->seqno)
                    /* evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=Â´ intead of `<Â´ due to u8 overflow */
                ) ) {
                    goto _CEU_GO_NEXT_;
                }
_CEU_GO_GO_:
                /* execute this trail */
                go.trl->evt   = CEU_IN__NONE;
                go.trl->seqno = app->seqno;   /* don't awake again */
                go.lbl = go.trl->lbl;
            }

            {
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif
                /*** CODE ***/
                int _ret = app->code(app, &go);
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_END:
#if defined(CEU_RET) || defined(CEU_OS)
                        app->isAlive = 0;
                        CEU_GC = 1;
#endif
                        goto _CEU_GO_QUIT_;
/*
                    case RET_GOTO:
                        goto _CEU_GOTO_;
*/
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_TRL:
                        goto _CEU_GO_CALL_TRL_;
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
                    case RET_ORG:
                        goto _CEU_GO_CALL_ORG_;
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
                    default:
                        break;
                }
            }
_CEU_GO_NEXT_:
            /* go.trl!=CEU_IN__ORG guaranteed here */
            if (go.trl->evt!=CEU_IN__STK && go.trl->seqno!=app->seqno)
                go.trl->seqno = app->seqno-1;   /* keeps the gap tight */
            go.trl++;
        }

        if (go.stki == 0) {
            break;      /* reaction has terminated */
        }
        go.evtp = go.stk[--go.stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        go.evto = (tceu_org*) go.stk[  go.stki].evto;
#endif
#endif
        go.evt  = go.stk[  go.stki].evt;
    }

_CEU_GO_QUIT_:;

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min_ != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min_);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late_ = 0;
    }
#endif
#endif

    /* free all orgs on "lst_free" on reaction termination */
#ifdef CEU_NEWS
    while (lst_free != NULL) {
        tceu_org* org = lst_free;
        lst_free = org->nxt_free;
#if    defined(CEU_NEWS_POOL) && !defined(CEU_NEWS_MALLOC)
        ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif  defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        if (org->pool == NULL)
            ceu_sys_free(org);
        else
            ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif !defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        ceu_sys_free(org);
#endif
    }
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS)
    if (app->isAlive)
#endif
        ceu_sys_go(app, CEU_IN_OS_START, CEU_EVTP((void*)NULL));
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    assert(_ceu_dyns_ == 0);
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

#ifdef CEU_OS

/* SYS_VECTOR
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_sys_malloc,
    (void*) &ceu_sys_free,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_clear,
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                       int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX)
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;

        if (sz == 0) {
            /* "param" is self-contained */
            qu->param = param;
        } else {
            /* "param" points to "buf" */
            qu->param.ptr = qu->buf;
            memcpy(qu->buf, buf, sz);
        }
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                  int sz, byte* buf) {
    return ceu_sys_queue_put(app, evt, param, sz, buf);
}

tceu_evtp ceu_sys_call (tceu_app* app, tceu_nevt evt, tceu_evtp param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt)
            continue;
#if defined(CEU_OS) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        tceu_evtp ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return CEU_EVTP((void*)NULL);
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk)
			cur = cur->nxt;
		if (cur->nxt != NULL)
            cur->nxt = lnk->nxt;
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_free(lnk);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive)
                _ceu_sys_unlink(cur);
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_free(app->data);
            ceu_sys_free(app);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->param);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->param);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init);
#endif

    tceu_app* app = (tceu_app*) ceu_sys_malloc(sizeof(tceu_app));
    if (app == NULL)
        return NULL;

    app->data = (tceu_org*) ceu_sys_malloc(size);
    if (app->data == NULL)
        return NULL;

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, CEU_EVTP((void*)NULL), 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_malloc(sizeof(tceu_lnk));
    if (lnk == NULL)
        return 0;

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif  /* CEU_OS */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif
#ifdef CEU_THREADS
#include <assert.h>
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (6)
#endif

/* native code from the Main class */


/* class definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

typedef void CEU_Executor;



typedef struct CEU_MoveX {
  struct tceu_org org;
  tceu_trl trls_[ 2 ];
  struct { /* BLOCK ln=21 */
    #line 23 "test.ceu"
int distance;
    union {
      struct { /* BLOCK ln=25 */
        union {
        };
      };
    };
  };

} CEU_MoveX;



typedef struct CEU_MoveY {
  struct tceu_org org;
  tceu_trl trls_[ 2 ];
  struct { /* BLOCK ln=32 */
    #line 34 "test.ceu"
int distance;
    union {
      struct { /* BLOCK ln=36 */
        union {
        };
      };
    };
  };

} CEU_MoveY;



typedef struct CEU_BoxTest {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=43 */
    union {
      struct { /* BLOCK ln=46 */
        #line 47 "test.ceu"
CEU_MoveX right;
      tceu_org_lnk __lnks_238_1[2];
        #line 55 "test.ceu"
CEU_MoveX left;
      tceu_org_lnk __lnks_238_3[2];
        #line 51 "test.ceu"
CEU_MoveY down;
      tceu_org_lnk __lnks_238_2[2];
        #line 59 "test.ceu"
CEU_MoveY up;
      tceu_org_lnk __lnks_238_4[2];
        union {
              struct { /* BLOCK ln=48 */
                union {
                };
              };
              struct { /* BLOCK ln=52 */
                union {
                };
              };
              struct { /* BLOCK ln=56 */
                union {
                };
              };
              struct { /* BLOCK ln=60 */
                union {
                };
              };
        };
      };
    };
  };

} CEU_BoxTest;



typedef struct CEU_DiagonalTest {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=67 */
    union {
      struct { /* BLOCK ln=70 */
        union {
          struct {
            struct { /* BLOCK ln=72 */
              #line 72 "test.ceu"
CEU_MoveX right_2;
            tceu_org_lnk __lnks_256_1[2];
              union {
                    struct { /* BLOCK ln=73 */
                      union {
                      };
                    };
              };
            };
            struct { /* BLOCK ln=77 */
              #line 77 "test.ceu"
CEU_MoveY down_3;
            tceu_org_lnk __lnks_270_4[2];
              union {
                    struct { /* BLOCK ln=78 */
                      union {
                      };
                    };
              };
            };
            u8 __and_271_1: 1;
            u8 __and_271_2: 1;
          };
          struct {
            struct { /* BLOCK ln=83 */
              #line 83 "test.ceu"
CEU_MoveX left_4;
            tceu_org_lnk __lnks_286_1[2];
              union {
                    struct { /* BLOCK ln=84 */
                      union {
                      };
                    };
              };
            };
            struct { /* BLOCK ln=88 */
              #line 88 "test.ceu"
CEU_MoveY up_5;
            tceu_org_lnk __lnks_301_4[2];
              union {
                    struct { /* BLOCK ln=89 */
                      union {
                      };
                    };
              };
            };
            u8 __and_302_1: 1;
            u8 __and_302_2: 1;
          };
        };
      };
    };
  };

} CEU_DiagonalTest;



typedef struct CEU_RulesTest {
  struct tceu_org org;
  tceu_trl trls_[ 9 ];
  struct { /* BLOCK ln=97 */
    union {
      struct { /* BLOCK ln=100 */
        union {
            struct { /* BLOCK ln=102 */
              union {
                  struct { /* BLOCK ln=103 */
                  u8 __fin_360_1: 1;
                    #line 104 "test.ceu"
CEU_MoveX right_2;
                  tceu_org_lnk __lnks_360_1[2];
                    union {
                          struct { /* BLOCK ln=105 */
                            union {
                            };
                          };
                          struct { /* BLOCK ln=108 */
                            union {
                            };
                          };
                      struct {
                        struct { /* BLOCK ln=112 */
                          union {
                              union {
                                struct { /* BLOCK ln=113 */
                                  union {
                                      struct { /* BLOCK ln=114 */
                                        union {
                                        };
                                      };
                                  };
                                };
                              };
                          };
                        };
                        struct { /* BLOCK ln=119 */
                          union {
                          };
                        };
                      };
                    };
                  };
                  struct { /* BLOCK ln=122 */
                    union {
                      struct {
                        struct { /* BLOCK ln=123 */
                          union {
                              union {
                                struct { /* BLOCK ln=124 */
                                  union {
                                      struct { /* BLOCK ln=125 */
                                        union {
                                        };
                                      };
                                  };
                                };
                              };
                          };
                        };
                        struct { /* BLOCK ln=130 */
                          union {
                              struct { /* BLOCK ln=131 */
                              u8 __fin_424_1: 1;
                                #line 132 "test.ceu"
CEU_MoveX left_3;
                              tceu_org_lnk __lnks_424_2[2];
                                union {
                                      struct { /* BLOCK ln=133 */
                                        union {
                                        };
                                      };
                                      struct { /* BLOCK ln=136 */
                                        union {
                                        };
                                      };
                                  struct {
                                    struct { /* BLOCK ln=140 */
                                      union {
                                          union {
                                            struct { /* BLOCK ln=141 */
                                              union {
                                                  struct { /* BLOCK ln=142 */
                                                    union {
                                                    };
                                                  };
                                              };
                                            };
                                          };
                                      };
                                    };
                                    struct { /* BLOCK ln=147 */
                                      union {
                                      };
                                    };
                                  };
                                };
                              };
                              struct { /* BLOCK ln=150 */
                                union {
                                  struct {
                                    struct { /* BLOCK ln=151 */
                                      union {
                                          union {
                                            struct { /* BLOCK ln=152 */
                                              union {
                                                  struct { /* BLOCK ln=153 */
                                                    union {
                                                    };
                                                  };
                                              };
                                            };
                                          };
                                      };
                                    };
                                    struct { /* BLOCK ln=158 */
                                      union {
                                          struct { /* BLOCK ln=159 */
                                          u8 __fin_488_1: 1;
                                            #line 160 "test.ceu"
CEU_MoveY down_4;
                                          tceu_org_lnk __lnks_488_3[2];
                                            union {
                                                  struct { /* BLOCK ln=161 */
                                                    union {
                                                    };
                                                  };
                                                  struct { /* BLOCK ln=164 */
                                                    union {
                                                    };
                                                  };
                                              struct {
                                                struct { /* BLOCK ln=167 */
                                                  union {
                                                      union {
                                                        struct { /* BLOCK ln=168 */
                                                          union {
                                                              struct { /* BLOCK ln=169 */
                                                                union {
                                                                };
                                                              };
                                                          };
                                                        };
                                                      };
                                                  };
                                                };
                                                struct { /* BLOCK ln=174 */
                                                  union {
                                                  };
                                                };
                                              };
                                            };
                                          };
                                          struct { /* BLOCK ln=177 */
                                            union {
                                              struct {
                                                struct { /* BLOCK ln=178 */
                                                  union {
                                                      union {
                                                        struct { /* BLOCK ln=179 */
                                                          union {
                                                              struct { /* BLOCK ln=180 */
                                                                union {
                                                                };
                                                              };
                                                          };
                                                        };
                                                      };
                                                  };
                                                };
                                                struct { /* BLOCK ln=185 */
                                                  union {
                                                      struct { /* BLOCK ln=186 */
                                                      u8 __fin_552_1: 1;
                                                        #line 187 "test.ceu"
CEU_MoveY up_5;
                                                      tceu_org_lnk __lnks_552_4[2];
                                                        union {
                                                              struct { /* BLOCK ln=188 */
                                                                union {
                                                                };
                                                              };
                                                              struct { /* BLOCK ln=191 */
                                                                union {
                                                                };
                                                              };
                                                          struct {
                                                            struct { /* BLOCK ln=194 */
                                                              union {
                                                                  union {
                                                                    struct { /* BLOCK ln=195 */
                                                                      union {
                                                                          struct { /* BLOCK ln=196 */
                                                                            union {
                                                                            };
                                                                          };
                                                                      };
                                                                    };
                                                                  };
                                                              };
                                                            };
                                                            struct { /* BLOCK ln=201 */
                                                              union {
                                                              };
                                                            };
                                                          };
                                                        };
                                                      };
                                                      struct { /* BLOCK ln=204 */
                                                        union {
                                                        };
                                                      };
                                                  };
                                                };
                                              };
                                            };
                                          };
                                      };
                                    };
                                  };
                                };
                              };
                          };
                        };
                      };
                    };
                  };
              };
            };
        };
      };
    };
  };

} CEU_RulesTest;


typedef struct CEU_Main {
  struct tceu_org org;
  tceu_trl trls_[ 3 ];
  struct { /* BLOCK ln=1 */
    union {
      struct { /* BLOCK ln=1 */
        #line 1 "_ceu_cpp_test.ceu.in"
int _ret_0;
        union {
            struct { /* BLOCK ln=1 */
              #line 223 "test.ceu"
CEU_RulesTest to_test;
            tceu_org_lnk __lnks_600_1[2];
              union {
                union {
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Main;




/* goto labels */
enum {
    MoveX_Awake_X_DONE_0 = 0,
    MoveX_EmitInt_cont_1 = 1,
    Class_MoveX = 2,
    MoveX_Class_free_MoveX_3 = 3,
    MoveY_Awake_Y_DONE_4 = 4,
    MoveY_EmitInt_cont_5 = 5,
    Class_MoveY = 6,
    MoveY_Class_free_MoveY_7 = 7,
    BoxTest_Start_cnt_8 = 8,
    BoxTest_Awake_ok_9 = 9,
    BoxTest_Start_cnt_10 = 10,
    BoxTest_Awake_ok_11 = 11,
    BoxTest_Start_cnt_12 = 12,
    BoxTest_Awake_ok_13 = 13,
    BoxTest_Start_cnt_14 = 14,
    BoxTest_Awake_ok_15 = 15,
    BoxTest_EmitInt_cont_16 = 16,
    BoxTest_Clear_17 = 17,
    Class_BoxTest = 18,
    BoxTest_Class_free_BoxTest_19 = 19,
    DiagonalTest_ParAnd_sub_2_20 = 20,
    DiagonalTest_ParAnd_chk_21 = 21,
    DiagonalTest_ParAnd_out_22 = 22,
    DiagonalTest_Start_cnt_23 = 23,
    DiagonalTest_Awake_ok_24 = 24,
    DiagonalTest_Clear_25 = 25,
    DiagonalTest_Start_cnt_26 = 26,
    DiagonalTest_Awake_ok_27 = 27,
    DiagonalTest_Clear_28 = 28,
    DiagonalTest_ParAnd_sub_2_29 = 29,
    DiagonalTest_ParAnd_chk_30 = 30,
    DiagonalTest_ParAnd_out_31 = 31,
    DiagonalTest_Start_cnt_32 = 32,
    DiagonalTest_Awake_ok_33 = 33,
    DiagonalTest_Clear_34 = 34,
    DiagonalTest_Start_cnt_35 = 35,
    DiagonalTest_Awake_ok_36 = 36,
    DiagonalTest_Clear_37 = 37,
    DiagonalTest_EmitInt_cont_38 = 38,
    Class_DiagonalTest = 39,
    DiagonalTest_Class_free_DiagonalTest_40 = 40,
    RulesTest_Start_cnt_41 = 41,
    RulesTest_ParOr_sub_2_42 = 42,
    RulesTest_ParOr_out_43 = 43,
    RulesTest_Awake_TICK_44 = 44,
    RulesTest_Awake_ok_45 = 45,
    RulesTest_Clear_46 = 46,
    RulesTest_Block__fin_47 = 47,
    RulesTest_Block_fin_cnt_48 = 48,
    RulesTest_Clear_49 = 49,
    RulesTest_ParOr_sub_2_50 = 50,
    RulesTest_ParOr_out_51 = 51,
    RulesTest_Awake_TICK_52 = 52,
    RulesTest_Start_cnt_53 = 53,
    RulesTest_ParOr_sub_2_54 = 54,
    RulesTest_ParOr_out_55 = 55,
    RulesTest_Awake_TICK_56 = 56,
    RulesTest_Awake_ok_57 = 57,
    RulesTest_Clear_58 = 58,
    RulesTest_Block__fin_59 = 59,
    RulesTest_Block_fin_cnt_60 = 60,
    RulesTest_Clear_61 = 61,
    RulesTest_ParOr_sub_2_62 = 62,
    RulesTest_ParOr_out_63 = 63,
    RulesTest_Awake_TICK_64 = 64,
    RulesTest_Start_cnt_65 = 65,
    RulesTest_ParOr_sub_2_66 = 66,
    RulesTest_ParOr_out_67 = 67,
    RulesTest_Awake_TICK_68 = 68,
    RulesTest_Awake_ok_69 = 69,
    RulesTest_Clear_70 = 70,
    RulesTest_Block__fin_71 = 71,
    RulesTest_Block_fin_cnt_72 = 72,
    RulesTest_Clear_73 = 73,
    RulesTest_ParOr_sub_2_74 = 74,
    RulesTest_ParOr_out_75 = 75,
    RulesTest_Awake_TICK_76 = 76,
    RulesTest_Start_cnt_77 = 77,
    RulesTest_ParOr_sub_2_78 = 78,
    RulesTest_ParOr_out_79 = 79,
    RulesTest_Awake_TICK_80 = 80,
    RulesTest_Awake_ok_81 = 81,
    RulesTest_Clear_82 = 82,
    RulesTest_Block__fin_83 = 83,
    RulesTest_Block_fin_cnt_84 = 84,
    RulesTest_Clear_85 = 85,
    RulesTest_Clear_86 = 86,
    RulesTest_Clear_87 = 87,
    RulesTest_Clear_88 = 88,
    RulesTest_Clear_89 = 89,
    RulesTest_EmitInt_cont_90 = 90,
    Class_RulesTest = 91,
    RulesTest_Class_free_RulesTest_92 = 92,
    Main_Set_out_93 = 93,
    Main_Awake_START_94 = 94,
    Main_Start_cnt_95 = 95,
    Main_Awake_ok_96 = 96,
    Main_Clear_97 = 97,
    Main_Clear_98 = 98,
    Class_Main = 99,
    Main_Class_free_Main_100 = 100,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][1];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][0];
    u16       ifcs_evts[CEU_NCLS][4];
    void*     ifcs_funs[CEU_NCLS][0];
    tceu_ntrl ifcs_trls[CEU_NCLS][0];
#endif
} _tceu_app;

/* TODO: remove from RAM */
static _tceu_app _CEU_APP = {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    {
		{1},
		{1},
		{1},
		{1},
		{1},
		{0}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{}
    },
    {
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,0}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{}
    }
#endif
};

/**********************************************************************/

#ifndef CEU_OS
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_190 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 190 */
/* NODE: Block 189 */

#line 48 "test.ceu"
    {/* NODE: Stmts 188 */

#line 48 "test.ceu"
    {/* NODE: SetExp 660 */

#line 48 "test.ceu"
/* SET: . */
#line 48 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = 10;
#line 48 "test.ceu"
    }
#line 48 "test.ceu"
/* CLEAR: Block (48) */
#line 48 "test.ceu"
    }
#line 48 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_202 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 202 */
/* NODE: Block 201 */

#line 52 "test.ceu"
    {/* NODE: Stmts 200 */

#line 52 "test.ceu"
    {/* NODE: SetExp 661 */

#line 52 "test.ceu"
/* SET: . */
#line 52 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = 10;
#line 52 "test.ceu"
    }
#line 52 "test.ceu"
/* CLEAR: Block (52) */
#line 52 "test.ceu"
    }
#line 52 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_215 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 215 */
/* NODE: Block 214 */

#line 56 "test.ceu"
    {/* NODE: Stmts 213 */

#line 56 "test.ceu"
    {/* NODE: SetExp 662 */

#line 56 "test.ceu"
/* SET: . */
#line 56 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (-10);
#line 56 "test.ceu"
    }
#line 56 "test.ceu"
/* CLEAR: Block (56) */
#line 56 "test.ceu"
    }
#line 56 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_228 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 228 */
/* NODE: Block 227 */

#line 60 "test.ceu"
    {/* NODE: Stmts 226 */

#line 60 "test.ceu"
    {/* NODE: SetExp 663 */

#line 60 "test.ceu"
/* SET: . */
#line 60 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (-10);
#line 60 "test.ceu"
    }
#line 60 "test.ceu"
/* CLEAR: Block (60) */
#line 60 "test.ceu"
    }
#line 60 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_250 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 250 */
/* NODE: Block 249 */

#line 73 "test.ceu"
    {/* NODE: Stmts 248 */

#line 73 "test.ceu"
    {/* NODE: SetExp 669 */

#line 73 "test.ceu"
/* SET: . */
#line 73 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = 20;
#line 73 "test.ceu"
    }
#line 73 "test.ceu"
/* CLEAR: Block (73) */
#line 73 "test.ceu"
    }
#line 73 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_264 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 264 */
/* NODE: Block 263 */

#line 78 "test.ceu"
    {/* NODE: Stmts 262 */

#line 78 "test.ceu"
    {/* NODE: SetExp 670 */

#line 78 "test.ceu"
/* SET: . */
#line 78 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = 20;
#line 78 "test.ceu"
    }
#line 78 "test.ceu"
/* CLEAR: Block (78) */
#line 78 "test.ceu"
    }
#line 78 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_280 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 280 */
/* NODE: Block 279 */

#line 84 "test.ceu"
    {/* NODE: Stmts 278 */

#line 84 "test.ceu"
    {/* NODE: SetExp 671 */

#line 84 "test.ceu"
/* SET: . */
#line 84 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (-20);
#line 84 "test.ceu"
    }
#line 84 "test.ceu"
/* CLEAR: Block (84) */
#line 84 "test.ceu"
    }
#line 84 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_295 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 295 */
/* NODE: Block 294 */

#line 89 "test.ceu"
    {/* NODE: Stmts 293 */

#line 89 "test.ceu"
    {/* NODE: SetExp 672 */

#line 89 "test.ceu"
/* SET: . */
#line 89 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (-20);
#line 89 "test.ceu"
    }
#line 89 "test.ceu"
/* CLEAR: Block (89) */
#line 89 "test.ceu"
    }
#line 89 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_330 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 330 */
/* NODE: Block 329 */

#line 105 "test.ceu"
    {/* NODE: Stmts 328 */

#line 105 "test.ceu"
    {/* NODE: SetExp 679 */

#line 105 "test.ceu"
/* SET: . */
#line 105 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (30-x());
#line 105 "test.ceu"
    }
#line 105 "test.ceu"
/* CLEAR: Block (105) */
#line 105 "test.ceu"
    }
#line 105 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_394 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 394 */
/* NODE: Block 393 */

#line 133 "test.ceu"
    {/* NODE: Stmts 392 */

#line 133 "test.ceu"
    {/* NODE: SetExp 690 */

#line 133 "test.ceu"
/* SET: . */
#line 133 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (30-x());
#line 133 "test.ceu"
    }
#line 133 "test.ceu"
/* CLEAR: Block (133) */
#line 133 "test.ceu"
    }
#line 133 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */
}
static void _ceu_constr_458 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 458 */
/* NODE: Block 457 */

#line 161 "test.ceu"
    {/* NODE: Stmts 456 */

#line 161 "test.ceu"
    {/* NODE: SetExp 701 */

#line 161 "test.ceu"
/* SET: . */
#line 161 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (30-y());
#line 161 "test.ceu"
    }
#line 161 "test.ceu"
/* CLEAR: Block (161) */
#line 161 "test.ceu"
    }
#line 161 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */
}
static void _ceu_constr_522 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 522 */
/* NODE: Block 521 */

#line 188 "test.ceu"
    {/* NODE: Stmts 520 */

#line 188 "test.ceu"
    {/* NODE: SetExp 712 */

#line 188 "test.ceu"
/* SET: . */
#line 188 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (30-y());
#line 188 "test.ceu"
    }
#line 188 "test.ceu"
/* CLEAR: Block (188) */
#line 188 "test.ceu"
    }
#line 188 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS
static tceu_evtp ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, tceu_evtp param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
#ifndef CEU_OS
            fprintf(stderr, "invalid call %d\n", evt);
#endif
#endif
    }
    return CEU_EVTP((void*)NULL);
}
#endif

static int ceu_app_go (tceu_app* _ceu_app, tceu_go* _ceu_go)
{
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_go->org;
#endif
    _ceu_app->lst.trl = _ceu_go->trl;
    _ceu_app->lst.lbl = _ceu_go->lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_go->org, _ceu_go->lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_go->lbl) {
        /* NODE: Root 750 */
/* NODE: Dcl_cls 0 */

#line 21 "test.ceu"
case Class_MoveX:;
#line 21 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 0;
#endif
/* NODE: Block 649 */

#line 21 "test.ceu"
    {/* NODE: Stmts 648 */

#line 21 "test.ceu"
    {/* NODE: Block 163 */

#line 25 "test.ceu"
    {/* NODE: Stmts 162 */

#line 25 "test.ceu"
    {/* NODE: CallStmt 154 */

#line 25 "test.ceu"
    printf("move x %d starting\n",((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: CallStmt 155 */

#line 26 "test.ceu"
    move_x(((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: AwaitExt 157 */

#line 27 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_X_DONE;
    _ceu_go->trl->lbl = MoveX_Awake_X_DONE_0;

#line 27 "test.ceu"
    	return RET_HALT;
#line 27 "test.ceu"
    case MoveX_Awake_X_DONE_0:;

#line 27 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 158 */

#line 28 "test.ceu"
    printf("move x %d done\n",((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: EmitInt 161 */

#line 29 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = MoveX_EmitInt_cont_1;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_MoveX*)_ceu_go->org);
#endif

#line 29 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case MoveX_EmitInt_cont_1:;

#line 25 "test.ceu"
    }
#line 25 "test.ceu"
/* CLEAR: Block (25) */
#line 25 "test.ceu"
    }
#line 25 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 21 "test.ceu"
    }
#line 21 "test.ceu"
/* CLEAR: Block (21) */
#line 21 "test.ceu"
    }
#line 21 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 21 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 21 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 1 */

#line 32 "test.ceu"
case Class_MoveY:;
#line 32 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 1;
#endif
/* NODE: Block 656 */

#line 32 "test.ceu"
    {/* NODE: Stmts 655 */

#line 32 "test.ceu"
    {/* NODE: Block 178 */

#line 36 "test.ceu"
    {/* NODE: Stmts 177 */

#line 36 "test.ceu"
    {/* NODE: CallStmt 169 */

#line 36 "test.ceu"
    printf("move y %d starting\n",((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: CallStmt 170 */

#line 37 "test.ceu"
    move_y(((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: AwaitExt 172 */

#line 38 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_Y_DONE;
    _ceu_go->trl->lbl = MoveY_Awake_Y_DONE_4;

#line 38 "test.ceu"
    	return RET_HALT;
#line 38 "test.ceu"
    case MoveY_Awake_Y_DONE_4:;

#line 38 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 173 */

#line 39 "test.ceu"
    printf("move y %d done\n",((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: EmitInt 176 */

#line 40 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = MoveY_EmitInt_cont_5;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_MoveY*)_ceu_go->org);
#endif

#line 40 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case MoveY_EmitInt_cont_5:;

#line 36 "test.ceu"
    }
#line 36 "test.ceu"
/* CLEAR: Block (36) */
#line 36 "test.ceu"
    }
#line 36 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 32 "test.ceu"
    }
#line 32 "test.ceu"
/* CLEAR: Block (32) */
#line 32 "test.ceu"
    }
#line 32 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 32 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 32 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 2 */

#line 43 "test.ceu"
case Class_BoxTest:;
#line 43 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 2;
#endif
/* NODE: Block 665 */

#line 43 "test.ceu"
    {/* NODE: Stmts 664 */

#line 43 "test.ceu"
    {/* NODE: Block 238 */

#line 46 "test.ceu"
    {
#line 46 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_238_1);

#line 46 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 2, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_238_2);

#line 46 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 3, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_238_3);

#line 46 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_238_4);

#line 46 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 237 */

#line 46 "test.ceu"
    {/* NODE: CallStmt 182 */

#line 46 "test.ceu"
    printf("boxtest starting\n");/* NODE: Dcl_var 191 */

#line 47 "test.ceu"
/* start org: right */
#line 47 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 47 "test.ceu"
            _ceu_constr_190(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)), _ceu_go);

#line 47 "test.ceu"
        }
}

#line 47 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_8,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)),Class_MoveX);
case BoxTest_Start_cnt_8:;
/* NODE: AwaitInt 194 */

#line 50 "test.ceu"
    _CEU_NO_194_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_9;

#line 50 "test.ceu"
    	return RET_HALT;
#line 50 "test.ceu"
    case BoxTest_Awake_ok_9:;

#line 50 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->right) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_194_;
    }
#endif

#line 50 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 203 */

#line 51 "test.ceu"
/* start org: down */
#line 51 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 51 "test.ceu"
            _ceu_constr_202(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)), _ceu_go);

#line 51 "test.ceu"
        }
}

#line 51 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_10,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)),Class_MoveY);
case BoxTest_Start_cnt_10:;
/* NODE: AwaitInt 206 */

#line 54 "test.ceu"
    _CEU_NO_206_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_11;

#line 54 "test.ceu"
    	return RET_HALT;
#line 54 "test.ceu"
    case BoxTest_Awake_ok_11:;

#line 54 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->down) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_206_;
    }
#endif

#line 54 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 216 */

#line 55 "test.ceu"
/* start org: left */
#line 55 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 3);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 55 "test.ceu"
            _ceu_constr_215(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)), _ceu_go);

#line 55 "test.ceu"
        }
}

#line 55 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_12,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)),Class_MoveX);
case BoxTest_Start_cnt_12:;
/* NODE: AwaitInt 219 */

#line 58 "test.ceu"
    _CEU_NO_219_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_13;

#line 58 "test.ceu"
    	return RET_HALT;
#line 58 "test.ceu"
    case BoxTest_Awake_ok_13:;

#line 58 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->left) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_219_;
    }
#endif

#line 58 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 229 */

#line 59 "test.ceu"
/* start org: up */
#line 59 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 59 "test.ceu"
            _ceu_constr_228(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)), _ceu_go);

#line 59 "test.ceu"
        }
}

#line 59 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_14,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)),Class_MoveY);
case BoxTest_Start_cnt_14:;
/* NODE: AwaitInt 232 */

#line 62 "test.ceu"
    _CEU_NO_232_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_15;

#line 62 "test.ceu"
    	return RET_HALT;
#line 62 "test.ceu"
    case BoxTest_Awake_ok_15:;

#line 62 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->up) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_232_;
    }
#endif

#line 62 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 233 */

#line 63 "test.ceu"
    printf("boxtest done\n");/* NODE: EmitInt 236 */

#line 64 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = BoxTest_EmitInt_cont_16;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_BoxTest*)_ceu_go->org);
#endif

#line 64 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case BoxTest_EmitInt_cont_16:;

#line 46 "test.ceu"
    }
#line 46 "test.ceu"
/* CLEAR: Block (46) */
#line 46 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = BoxTest_Clear_17;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case BoxTest_Clear_17:;

#line 46 "test.ceu"
    }
#line 46 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 43 "test.ceu"
    }
#line 43 "test.ceu"
/* CLEAR: Block (43) */
#line 43 "test.ceu"
    }
#line 43 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 43 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 43 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 3 */

#line 67 "test.ceu"
case Class_DiagonalTest:;
#line 67 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 3;
#endif
/* NODE: Block 674 */

#line 67 "test.ceu"
    {/* NODE: Stmts 673 */

#line 67 "test.ceu"
    {/* NODE: Block 308 */

#line 70 "test.ceu"
    {/* NODE: Stmts 307 */

#line 70 "test.ceu"
    {/* NODE: CallStmt 242 */

#line 70 "test.ceu"
    printf("diagonaltest starting\n");/* NODE: ParAnd 271 */

#line 71 "test.ceu"
/* close ParAnd gates */
#line 71 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_271_1 = 0;
#line 71 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_271_2 = 0;
#line 71 "test.ceu"
/* ParAnd: spawn subs */
#line 71 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = DiagonalTest_ParAnd_sub_2_20;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 256 */

#line 72 "test.ceu"
    {
#line 72 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_256_1);

#line 72 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 255 */

#line 72 "test.ceu"
    {/* NODE: Dcl_var 251 */

#line 72 "test.ceu"
/* start org: right */
#line 72 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 72 "test.ceu"
            _ceu_constr_250(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)), _ceu_go);

#line 72 "test.ceu"
        }
}

#line 72 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_23,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)),Class_MoveX);
case DiagonalTest_Start_cnt_23:;
/* NODE: AwaitInt 254 */

#line 75 "test.ceu"
    _CEU_NO_254_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_24;

#line 75 "test.ceu"
    	return RET_HALT;
#line 75 "test.ceu"
    case DiagonalTest_Awake_ok_24:;

#line 75 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->right_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_254_;
    }
#endif

#line 75 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 72 "test.ceu"
    }
#line 72 "test.ceu"
/* CLEAR: Block (72) */
#line 72 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_25;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case DiagonalTest_Clear_25:;

#line 72 "test.ceu"
    }
#line 72 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 71 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_271_1 = 1;
#line 71 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_21;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 71 "test.ceu"
case DiagonalTest_ParAnd_sub_2_20:;/* NODE: Block 270 */

#line 77 "test.ceu"
    {
#line 77 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_270_4);

#line 77 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 269 */

#line 77 "test.ceu"
    {/* NODE: Dcl_var 265 */

#line 77 "test.ceu"
/* start org: down */
#line 77 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 77 "test.ceu"
            _ceu_constr_264(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)), _ceu_go);

#line 77 "test.ceu"
        }
}

#line 77 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_26,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)),Class_MoveY);
case DiagonalTest_Start_cnt_26:;
/* NODE: AwaitInt 268 */

#line 80 "test.ceu"
    _CEU_NO_268_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_27;

#line 80 "test.ceu"
    	return RET_HALT;
#line 80 "test.ceu"
    case DiagonalTest_Awake_ok_27:;

#line 80 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->down_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_268_;
    }
#endif

#line 80 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 77 "test.ceu"
    }
#line 77 "test.ceu"
/* CLEAR: Block (77) */
#line 77 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_28;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case DiagonalTest_Clear_28:;

#line 77 "test.ceu"
    }
#line 77 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 71 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_271_2 = 1;
#line 71 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_21;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 71 "test.ceu"
case DiagonalTest_ParAnd_chk_21:;
#line 71 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_271_1) {
#line 71 "test.ceu"
    	return RET_HALT;
#line 71 "test.ceu"
    }
#line 71 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_271_2) {
#line 71 "test.ceu"
    	return RET_HALT;
#line 71 "test.ceu"
    }
#line 71 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: ParAnd 302 */

#line 82 "test.ceu"
/* close ParAnd gates */
#line 82 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_302_1 = 0;
#line 82 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_302_2 = 0;
#line 82 "test.ceu"
/* ParAnd: spawn subs */
#line 82 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = DiagonalTest_ParAnd_sub_2_29;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 286 */

#line 83 "test.ceu"
    {
#line 83 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_286_1);

#line 83 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 285 */

#line 83 "test.ceu"
    {/* NODE: Dcl_var 281 */

#line 83 "test.ceu"
/* start org: left */
#line 83 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 83 "test.ceu"
            _ceu_constr_280(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)), _ceu_go);

#line 83 "test.ceu"
        }
}

#line 83 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_32,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)),Class_MoveX);
case DiagonalTest_Start_cnt_32:;
/* NODE: AwaitInt 284 */

#line 86 "test.ceu"
    _CEU_NO_284_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_33;

#line 86 "test.ceu"
    	return RET_HALT;
#line 86 "test.ceu"
    case DiagonalTest_Awake_ok_33:;

#line 86 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->left_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_284_;
    }
#endif

#line 86 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 83 "test.ceu"
    }
#line 83 "test.ceu"
/* CLEAR: Block (83) */
#line 83 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_34;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case DiagonalTest_Clear_34:;

#line 83 "test.ceu"
    }
#line 83 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 82 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_302_1 = 1;
#line 82 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_30;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 82 "test.ceu"
case DiagonalTest_ParAnd_sub_2_29:;/* NODE: Block 301 */

#line 88 "test.ceu"
    {
#line 88 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_301_4);

#line 88 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 300 */

#line 88 "test.ceu"
    {/* NODE: Dcl_var 296 */

#line 88 "test.ceu"
/* start org: up */
#line 88 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 88 "test.ceu"
            _ceu_constr_295(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)), _ceu_go);

#line 88 "test.ceu"
        }
}

#line 88 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_35,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)),Class_MoveY);
case DiagonalTest_Start_cnt_35:;
/* NODE: AwaitInt 299 */

#line 91 "test.ceu"
    _CEU_NO_299_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_36;

#line 91 "test.ceu"
    	return RET_HALT;
#line 91 "test.ceu"
    case DiagonalTest_Awake_ok_36:;

#line 91 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->up_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_299_;
    }
#endif

#line 91 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 88 "test.ceu"
    }
#line 88 "test.ceu"
/* CLEAR: Block (88) */
#line 88 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_37;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case DiagonalTest_Clear_37:;

#line 88 "test.ceu"
    }
#line 88 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 82 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_302_2 = 1;
#line 82 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_30;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 82 "test.ceu"
case DiagonalTest_ParAnd_chk_30:;
#line 82 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_302_1) {
#line 82 "test.ceu"
    	return RET_HALT;
#line 82 "test.ceu"
    }
#line 82 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_302_2) {
#line 82 "test.ceu"
    	return RET_HALT;
#line 82 "test.ceu"
    }
#line 82 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: CallStmt 303 */

#line 93 "test.ceu"
    printf("diagonaltest done\n");/* NODE: EmitInt 306 */

#line 94 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = DiagonalTest_EmitInt_cont_38;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_DiagonalTest*)_ceu_go->org);
#endif

#line 94 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case DiagonalTest_EmitInt_cont_38:;

#line 70 "test.ceu"
    }
#line 70 "test.ceu"
/* CLEAR: Block (70) */
#line 70 "test.ceu"
    }
#line 70 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 67 "test.ceu"
    }
#line 67 "test.ceu"
/* CLEAR: Block (67) */
#line 67 "test.ceu"
    }
#line 67 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 67 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 67 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 4 */

#line 97 "test.ceu"
case Class_RulesTest:;
#line 97 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 4;
#endif
/* NODE: Block 719 */

#line 97 "test.ceu"
    {/* NODE: Stmts 718 */

#line 97 "test.ceu"
    {/* NODE: Block 585 */

#line 100 "test.ceu"
    {/* NODE: Stmts 584 */

#line 100 "test.ceu"
    {/* NODE: CallStmt 312 */

#line 100 "test.ceu"
    printf("rulestest starting\n");/* NODE: Loop 678 */

#line 101 "test.ceu"
    for (;;) {
/* NODE: Block 576 */

#line 102 "test.ceu"
    {/* NODE: Stmts 575 */

#line 102 "test.ceu"
    {/* NODE: If 574 */

#line 102 "test.ceu"
    if ((x()<30)) {
/* NODE: Block 360 */

#line 103 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 4 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 4 ].lbl   = RulesTest_Block__fin_47;
_ceu_go->org->trls[ 4 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 103 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_360_1 = 0;
#line 103 "test.ceu"
    {
#line 103 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_RulesTest*)_ceu_go->org)->__lnks_360_1);

#line 103 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 359 */

#line 103 "test.ceu"
    {/* NODE: CallStmt 318 */

#line 103 "test.ceu"
    printf("rulestest starting right\n");/* NODE: Dcl_var 331 */

#line 104 "test.ceu"
/* start org: right */
#line 104 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->right_2)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 104 "test.ceu"
            _ceu_constr_330(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->right_2)), _ceu_go);

#line 104 "test.ceu"
        }
}

#line 104 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, RulesTest_Start_cnt_41,((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->right_2)),Class_MoveX);
case RulesTest_Start_cnt_41:;
/* NODE: Finalize 336 */

#line 107 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_360_1 = 1;/* NODE: ParOr 358 */

#line 111 "test.ceu"
/* ParOr: spawn subs */
#line 111 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_42;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 352 */

#line 112 "test.ceu"
    {/* NODE: Stmts 351 */

#line 112 "test.ceu"
    {/* NODE: Loop 682 */

#line 112 "test.ceu"
    for (;;) {
/* NODE: Stmts 681 */

#line 112 "test.ceu"
    {/* NODE: AwaitExt 680 */

#line 112 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_44;

#line 112 "test.ceu"
    	return RET_HALT;
#line 112 "test.ceu"
    case RulesTest_Awake_TICK_44:;

#line 112 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 349 */

#line 113 "test.ceu"
    {/* NODE: Stmts 348 */

#line 113 "test.ceu"
    {/* NODE: If 684 */

#line 113 "test.ceu"
    if ((x()>=30)) {
/* NODE: Block 346 */

#line 114 "test.ceu"
    {/* NODE: Stmts 345 */

#line 114 "test.ceu"
    {/* NODE: CallStmt 343 */

#line 114 "test.ceu"
    printf("right disqualified\n");/* NODE: Break 344 */

#line 115 "test.ceu"
    break;
#line 114 "test.ceu"
    }
#line 114 "test.ceu"
/* CLEAR: Block (114) */
#line 114 "test.ceu"
    }} else {
/* NODE: Nothing 683 */
}

#line 113 "test.ceu"
    }
#line 113 "test.ceu"
/* CLEAR: Block (113) */
#line 113 "test.ceu"
    }
#line 113 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 112 "test.ceu"
    }
#line 112 "test.ceu"
    }

#line 112 "test.ceu"
/* CLEAR: Loop (112) */
#line 112 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];

#line 112 "test.ceu"
    }
#line 112 "test.ceu"
/* CLEAR: Block (112) */
#line 112 "test.ceu"
    }
#line 112 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 111 "test.ceu"
/* PAROR JOIN */
#line 111 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_43;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 111 "test.ceu"
case RulesTest_ParOr_sub_2_42:;/* NODE: Block 357 */

#line 119 "test.ceu"
    {/* NODE: Stmts 356 */

#line 119 "test.ceu"
    {/* NODE: AwaitInt 355 */

#line 119 "test.ceu"
    _CEU_NO_355_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = RulesTest_Awake_ok_45;

#line 119 "test.ceu"
    	return RET_HALT;
#line 119 "test.ceu"
    case RulesTest_Awake_ok_45:;

#line 119 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_RulesTest*)_ceu_go->org)->right_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_355_;
    }
#endif

#line 119 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 119 "test.ceu"
    }
#line 119 "test.ceu"
/* CLEAR: Block (119) */
#line 119 "test.ceu"
    }
#line 119 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 111 "test.ceu"
/* PAROR JOIN */
#line 111 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_43;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 111 "test.ceu"
case RulesTest_ParOr_out_43:;
#line 111 "test.ceu"
/* CLEAR: ParOr (111) */
#line 111 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_46;
}
return ceu_out_clear(_ceu_go, 3,                     &_ceu_go->org->trls[ 4 ]);

case RulesTest_Clear_46:;

#line 111 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];

#line 103 "test.ceu"
    }
#line 103 "test.ceu"
    _ceu_go->lbl = RulesTest_Block_fin_cnt_48;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 103 "test.ceu"
case RulesTest_Block__fin_47:;
#line 103 "test.ceu"
    if (((CEU_RulesTest*)_ceu_go->org)->__fin_360_1) {
/* NODE: Finally 335 */
/* NODE: Block 334 */

#line 108 "test.ceu"
    {/* NODE: Stmts 333 */

#line 108 "test.ceu"
    {/* NODE: CallStmt 332 */

#line 108 "test.ceu"
    cancel_x();
#line 108 "test.ceu"
    }
#line 108 "test.ceu"
/* CLEAR: Block (108) */
#line 108 "test.ceu"
    }
#line 108 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}

#line 103 "test.ceu"
    	return RET_HALT;
#line 103 "test.ceu"
case RulesTest_Block_fin_cnt_48:;
#line 103 "test.ceu"
/* CLEAR: Block (103) */
#line 103 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_49;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_49:;

#line 103 "test.ceu"
    }
#line 103 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 573 */

#line 122 "test.ceu"
    {/* NODE: Stmts 572 */

#line 122 "test.ceu"
    {/* NODE: ParOr 571 */

#line 122 "test.ceu"
/* ParOr: spawn subs */
#line 122 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_50;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 376 */

#line 123 "test.ceu"
    {/* NODE: Stmts 375 */

#line 123 "test.ceu"
    {/* NODE: Loop 687 */

#line 123 "test.ceu"
    for (;;) {
/* NODE: Stmts 686 */

#line 123 "test.ceu"
    {/* NODE: AwaitExt 685 */

#line 123 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_52;

#line 123 "test.ceu"
    	return RET_HALT;
#line 123 "test.ceu"
    case RulesTest_Awake_TICK_52:;

#line 123 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 373 */

#line 124 "test.ceu"
    {/* NODE: Stmts 372 */

#line 124 "test.ceu"
    {/* NODE: If 689 */

#line 124 "test.ceu"
    if ((x()<30)) {
/* NODE: Block 370 */

#line 125 "test.ceu"
    {/* NODE: Stmts 369 */

#line 125 "test.ceu"
    {/* NODE: CallStmt 367 */

#line 125 "test.ceu"
    printf("right preempts\n");/* NODE: Break 368 */

#line 126 "test.ceu"
    break;
#line 125 "test.ceu"
    }
#line 125 "test.ceu"
/* CLEAR: Block (125) */
#line 125 "test.ceu"
    }} else {
/* NODE: Nothing 688 */
}

#line 124 "test.ceu"
    }
#line 124 "test.ceu"
/* CLEAR: Block (124) */
#line 124 "test.ceu"
    }
#line 124 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 123 "test.ceu"
    }
#line 123 "test.ceu"
    }

#line 123 "test.ceu"
/* CLEAR: Loop (123) */
#line 123 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 123 "test.ceu"
    }
#line 123 "test.ceu"
/* CLEAR: Block (123) */
#line 123 "test.ceu"
    }
#line 123 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 122 "test.ceu"
/* PAROR JOIN */
#line 122 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_51;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 122 "test.ceu"
case RulesTest_ParOr_sub_2_50:;/* NODE: Block 570 */

#line 130 "test.ceu"
    {/* NODE: Stmts 569 */

#line 130 "test.ceu"
    {/* NODE: If 568 */

#line 130 "test.ceu"
    if ((x()>30)) {
/* NODE: Block 424 */

#line 131 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 5 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 5 ].lbl   = RulesTest_Block__fin_59;
_ceu_go->org->trls[ 5 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 131 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_424_1 = 0;
#line 131 "test.ceu"
    {
#line 131 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 2, (tceu_org_lnk*) &((CEU_RulesTest*)_ceu_go->org)->__lnks_424_2);

#line 131 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 3 ];
/* NODE: Stmts 423 */

#line 131 "test.ceu"
    {/* NODE: CallStmt 382 */

#line 131 "test.ceu"
    printf("rulestest starting left\n");/* NODE: Dcl_var 395 */

#line 132 "test.ceu"
/* start org: left */
#line 132 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->left_3)),2,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 132 "test.ceu"
            _ceu_constr_394(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->left_3)), _ceu_go);

#line 132 "test.ceu"
        }
}

#line 132 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, RulesTest_Start_cnt_53,((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->left_3)),Class_MoveX);
case RulesTest_Start_cnt_53:;
/* NODE: Finalize 400 */

#line 135 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_424_1 = 1;/* NODE: ParOr 422 */

#line 139 "test.ceu"
/* ParOr: spawn subs */
#line 139 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 4 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_54;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 416 */

#line 140 "test.ceu"
    {/* NODE: Stmts 415 */

#line 140 "test.ceu"
    {/* NODE: Loop 693 */

#line 140 "test.ceu"
    for (;;) {
/* NODE: Stmts 692 */

#line 140 "test.ceu"
    {/* NODE: AwaitExt 691 */

#line 140 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_56;

#line 140 "test.ceu"
    	return RET_HALT;
#line 140 "test.ceu"
    case RulesTest_Awake_TICK_56:;

#line 140 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 413 */

#line 141 "test.ceu"
    {/* NODE: Stmts 412 */

#line 141 "test.ceu"
    {/* NODE: If 695 */

#line 141 "test.ceu"
    if ((x()<=30)) {
/* NODE: Block 410 */

#line 142 "test.ceu"
    {/* NODE: Stmts 409 */

#line 142 "test.ceu"
    {/* NODE: CallStmt 407 */

#line 142 "test.ceu"
    printf("left disqualified\n");/* NODE: Break 408 */

#line 143 "test.ceu"
    break;
#line 142 "test.ceu"
    }
#line 142 "test.ceu"
/* CLEAR: Block (142) */
#line 142 "test.ceu"
    }} else {
/* NODE: Nothing 694 */
}

#line 141 "test.ceu"
    }
#line 141 "test.ceu"
/* CLEAR: Block (141) */
#line 141 "test.ceu"
    }
#line 141 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 140 "test.ceu"
    }
#line 140 "test.ceu"
    }

#line 140 "test.ceu"
/* CLEAR: Loop (140) */
#line 140 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 3 ];

#line 140 "test.ceu"
    }
#line 140 "test.ceu"
/* CLEAR: Block (140) */
#line 140 "test.ceu"
    }
#line 140 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 139 "test.ceu"
/* PAROR JOIN */
#line 139 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_55;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 139 "test.ceu"
case RulesTest_ParOr_sub_2_54:;/* NODE: Block 421 */

#line 147 "test.ceu"
    {/* NODE: Stmts 420 */

#line 147 "test.ceu"
    {/* NODE: AwaitInt 419 */

#line 147 "test.ceu"
    _CEU_NO_419_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = RulesTest_Awake_ok_57;

#line 147 "test.ceu"
    	return RET_HALT;
#line 147 "test.ceu"
    case RulesTest_Awake_ok_57:;

#line 147 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_RulesTest*)_ceu_go->org)->left_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_419_;
    }
#endif

#line 147 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 147 "test.ceu"
    }
#line 147 "test.ceu"
/* CLEAR: Block (147) */
#line 147 "test.ceu"
    }
#line 147 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */

#line 139 "test.ceu"
/* PAROR JOIN */
#line 139 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_55;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 139 "test.ceu"
case RulesTest_ParOr_out_55:;
#line 139 "test.ceu"
/* CLEAR: ParOr (139) */
#line 139 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_58;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 5 ]);

case RulesTest_Clear_58:;

#line 139 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 3 ];

#line 131 "test.ceu"
    }
#line 131 "test.ceu"
    _ceu_go->lbl = RulesTest_Block_fin_cnt_60;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 131 "test.ceu"
case RulesTest_Block__fin_59:;
#line 131 "test.ceu"
    if (((CEU_RulesTest*)_ceu_go->org)->__fin_424_1) {
/* NODE: Finally 399 */
/* NODE: Block 398 */

#line 136 "test.ceu"
    {/* NODE: Stmts 397 */

#line 136 "test.ceu"
    {/* NODE: CallStmt 396 */

#line 136 "test.ceu"
    cancel_x();
#line 136 "test.ceu"
    }
#line 136 "test.ceu"
/* CLEAR: Block (136) */
#line 136 "test.ceu"
    }
#line 136 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */
}

#line 131 "test.ceu"
    	return RET_HALT;
#line 131 "test.ceu"
case RulesTest_Block_fin_cnt_60:;
#line 131 "test.ceu"
/* CLEAR: Block (131) */
#line 131 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_61;
}
return ceu_out_clear(_ceu_go, 2,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_61:;

#line 131 "test.ceu"
    }
#line 131 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */
} else {
/* NODE: Block 567 */

#line 150 "test.ceu"
    {/* NODE: Stmts 566 */

#line 150 "test.ceu"
    {/* NODE: ParOr 565 */

#line 150 "test.ceu"
/* ParOr: spawn subs */
#line 150 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_62;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 440 */

#line 151 "test.ceu"
    {/* NODE: Stmts 439 */

#line 151 "test.ceu"
    {/* NODE: Loop 698 */

#line 151 "test.ceu"
    for (;;) {
/* NODE: Stmts 697 */

#line 151 "test.ceu"
    {/* NODE: AwaitExt 696 */

#line 151 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_64;

#line 151 "test.ceu"
    	return RET_HALT;
#line 151 "test.ceu"
    case RulesTest_Awake_TICK_64:;

#line 151 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 437 */

#line 152 "test.ceu"
    {/* NODE: Stmts 436 */

#line 152 "test.ceu"
    {/* NODE: If 700 */

#line 152 "test.ceu"
    if ((x()>30)) {
/* NODE: Block 434 */

#line 153 "test.ceu"
    {/* NODE: Stmts 433 */

#line 153 "test.ceu"
    {/* NODE: CallStmt 431 */

#line 153 "test.ceu"
    printf("left preempts\n");/* NODE: Break 432 */

#line 154 "test.ceu"
    break;
#line 153 "test.ceu"
    }
#line 153 "test.ceu"
/* CLEAR: Block (153) */
#line 153 "test.ceu"
    }} else {
/* NODE: Nothing 699 */
}

#line 152 "test.ceu"
    }
#line 152 "test.ceu"
/* CLEAR: Block (152) */
#line 152 "test.ceu"
    }
#line 152 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */

#line 151 "test.ceu"
    }
#line 151 "test.ceu"
    }

#line 151 "test.ceu"
/* CLEAR: Loop (151) */
#line 151 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 1 ];

#line 151 "test.ceu"
    }
#line 151 "test.ceu"
/* CLEAR: Block (151) */
#line 151 "test.ceu"
    }
#line 151 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */

#line 150 "test.ceu"
/* PAROR JOIN */
#line 150 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_63;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 150 "test.ceu"
case RulesTest_ParOr_sub_2_62:;/* NODE: Block 564 */

#line 158 "test.ceu"
    {/* NODE: Stmts 563 */

#line 158 "test.ceu"
    {/* NODE: If 562 */

#line 158 "test.ceu"
    if ((y()<30)) {
/* NODE: Block 488 */

#line 159 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 6 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 6 ].lbl   = RulesTest_Block__fin_71;
_ceu_go->org->trls[ 6 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 159 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_488_1 = 0;
#line 159 "test.ceu"
    {
#line 159 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 3, (tceu_org_lnk*) &((CEU_RulesTest*)_ceu_go->org)->__lnks_488_3);

#line 159 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 4 ];
/* NODE: Stmts 487 */

#line 159 "test.ceu"
    {/* NODE: CallStmt 446 */

#line 159 "test.ceu"
    printf("rulestest starting down\n");/* NODE: Dcl_var 459 */

#line 160 "test.ceu"
/* start org: down */
#line 160 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->down_4)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 3);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 160 "test.ceu"
            _ceu_constr_458(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->down_4)), _ceu_go);

#line 160 "test.ceu"
        }
}

#line 160 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, RulesTest_Start_cnt_65,((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->down_4)),Class_MoveY);
case RulesTest_Start_cnt_65:;
/* NODE: Finalize 464 */

#line 163 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_488_1 = 1;/* NODE: ParOr 486 */

#line 166 "test.ceu"
/* ParOr: spawn subs */
#line 166 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 5 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_66;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 480 */

#line 167 "test.ceu"
    {/* NODE: Stmts 479 */

#line 167 "test.ceu"
    {/* NODE: Loop 704 */

#line 167 "test.ceu"
    for (;;) {
/* NODE: Stmts 703 */

#line 167 "test.ceu"
    {/* NODE: AwaitExt 702 */

#line 167 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_68;

#line 167 "test.ceu"
    	return RET_HALT;
#line 167 "test.ceu"
    case RulesTest_Awake_TICK_68:;

#line 167 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 477 */

#line 168 "test.ceu"
    {/* NODE: Stmts 476 */

#line 168 "test.ceu"
    {/* NODE: If 706 */

#line 168 "test.ceu"
    if ((y()>=30)) {
/* NODE: Block 474 */

#line 169 "test.ceu"
    {/* NODE: Stmts 473 */

#line 169 "test.ceu"
    {/* NODE: CallStmt 471 */

#line 169 "test.ceu"
    printf("down disqualified\n");/* NODE: Break 472 */

#line 170 "test.ceu"
    break;
#line 169 "test.ceu"
    }
#line 169 "test.ceu"
/* CLEAR: Block (169) */
#line 169 "test.ceu"
    }} else {
/* NODE: Nothing 705 */
}

#line 168 "test.ceu"
    }
#line 168 "test.ceu"
/* CLEAR: Block (168) */
#line 168 "test.ceu"
    }
#line 168 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */

#line 167 "test.ceu"
    }
#line 167 "test.ceu"
    }

#line 167 "test.ceu"
/* CLEAR: Loop (167) */
#line 167 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 4 ];

#line 167 "test.ceu"
    }
#line 167 "test.ceu"
/* CLEAR: Block (167) */
#line 167 "test.ceu"
    }
#line 167 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */

#line 166 "test.ceu"
/* PAROR JOIN */
#line 166 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_67;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 166 "test.ceu"
case RulesTest_ParOr_sub_2_66:;/* NODE: Block 485 */

#line 174 "test.ceu"
    {/* NODE: Stmts 484 */

#line 174 "test.ceu"
    {/* NODE: AwaitInt 483 */

#line 174 "test.ceu"
    _CEU_NO_483_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = RulesTest_Awake_ok_69;

#line 174 "test.ceu"
    	return RET_HALT;
#line 174 "test.ceu"
    case RulesTest_Awake_ok_69:;

#line 174 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_RulesTest*)_ceu_go->org)->down_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_483_;
    }
#endif

#line 174 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 174 "test.ceu"
    }
#line 174 "test.ceu"
/* CLEAR: Block (174) */
#line 174 "test.ceu"
    }
#line 174 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */

#line 166 "test.ceu"
/* PAROR JOIN */
#line 166 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_67;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 166 "test.ceu"
case RulesTest_ParOr_out_67:;
#line 166 "test.ceu"
/* CLEAR: ParOr (166) */
#line 166 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 4 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_70;
}
return ceu_out_clear(_ceu_go, 5,                     &_ceu_go->org->trls[ 6 ]);

case RulesTest_Clear_70:;

#line 166 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 4 ];

#line 159 "test.ceu"
    }
#line 159 "test.ceu"
    _ceu_go->lbl = RulesTest_Block_fin_cnt_72;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 159 "test.ceu"
case RulesTest_Block__fin_71:;
#line 159 "test.ceu"
    if (((CEU_RulesTest*)_ceu_go->org)->__fin_488_1) {
/* NODE: Finally 463 */
/* NODE: Block 462 */

#line 164 "test.ceu"
    {/* NODE: Stmts 461 */

#line 164 "test.ceu"
    {/* NODE: CallStmt 460 */

#line 164 "test.ceu"
    cancel_y();
#line 164 "test.ceu"
    }
#line 164 "test.ceu"
/* CLEAR: Block (164) */
#line 164 "test.ceu"
    }
#line 164 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */
}

#line 159 "test.ceu"
    	return RET_HALT;
#line 159 "test.ceu"
case RulesTest_Block_fin_cnt_72:;
#line 159 "test.ceu"
/* CLEAR: Block (159) */
#line 159 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_73;
}
return ceu_out_clear(_ceu_go, 3,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_73:;

#line 159 "test.ceu"
    }
#line 159 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
} else {
/* NODE: Block 561 */

#line 177 "test.ceu"
    {/* NODE: Stmts 560 */

#line 177 "test.ceu"
    {/* NODE: ParOr 559 */

#line 177 "test.ceu"
/* ParOr: spawn subs */
#line 177 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_74;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 504 */

#line 178 "test.ceu"
    {/* NODE: Stmts 503 */

#line 178 "test.ceu"
    {/* NODE: Loop 709 */

#line 178 "test.ceu"
    for (;;) {
/* NODE: Stmts 708 */

#line 178 "test.ceu"
    {/* NODE: AwaitExt 707 */

#line 178 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_76;

#line 178 "test.ceu"
    	return RET_HALT;
#line 178 "test.ceu"
    case RulesTest_Awake_TICK_76:;

#line 178 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 501 */

#line 179 "test.ceu"
    {/* NODE: Stmts 500 */

#line 179 "test.ceu"
    {/* NODE: If 711 */

#line 179 "test.ceu"
    if ((y()<30)) {
/* NODE: Block 498 */

#line 180 "test.ceu"
    {/* NODE: Stmts 497 */

#line 180 "test.ceu"
    {/* NODE: CallStmt 495 */

#line 180 "test.ceu"
    printf("down preempts\n");/* NODE: Break 496 */

#line 181 "test.ceu"
    break;
#line 180 "test.ceu"
    }
#line 180 "test.ceu"
/* CLEAR: Block (180) */
#line 180 "test.ceu"
    }} else {
/* NODE: Nothing 710 */
}

#line 179 "test.ceu"
    }
#line 179 "test.ceu"
/* CLEAR: Block (179) */
#line 179 "test.ceu"
    }
#line 179 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 178 "test.ceu"
    }
#line 178 "test.ceu"
    }

#line 178 "test.ceu"
/* CLEAR: Loop (178) */
#line 178 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];

#line 178 "test.ceu"
    }
#line 178 "test.ceu"
/* CLEAR: Block (178) */
#line 178 "test.ceu"
    }
#line 178 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 177 "test.ceu"
/* PAROR JOIN */
#line 177 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_75;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 177 "test.ceu"
case RulesTest_ParOr_sub_2_74:;/* NODE: Block 558 */

#line 185 "test.ceu"
    {/* NODE: Stmts 557 */

#line 185 "test.ceu"
    {/* NODE: If 556 */

#line 185 "test.ceu"
    if ((y()>30)) {
/* NODE: Block 552 */

#line 186 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 7 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 7 ].lbl   = RulesTest_Block__fin_83;
_ceu_go->org->trls[ 7 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 186 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_552_1 = 0;
#line 186 "test.ceu"
    {
#line 186 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_RulesTest*)_ceu_go->org)->__lnks_552_4);

#line 186 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 551 */

#line 186 "test.ceu"
    {/* NODE: CallStmt 510 */

#line 186 "test.ceu"
    printf("rulestest starting up\n");/* NODE: Dcl_var 523 */

#line 187 "test.ceu"
/* start org: up */
#line 187 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->up_5)),2,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 187 "test.ceu"
            _ceu_constr_522(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->up_5)), _ceu_go);

#line 187 "test.ceu"
        }
}

#line 187 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, RulesTest_Start_cnt_77,((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->up_5)),Class_MoveY);
case RulesTest_Start_cnt_77:;
/* NODE: Finalize 528 */

#line 190 "test.ceu"
    ((CEU_RulesTest*)_ceu_go->org)->__fin_552_1 = 1;/* NODE: ParOr 550 */

#line 193 "test.ceu"
/* ParOr: spawn subs */
#line 193 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 6 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = RulesTest_ParOr_sub_2_78;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 544 */

#line 194 "test.ceu"
    {/* NODE: Stmts 543 */

#line 194 "test.ceu"
    {/* NODE: Loop 715 */

#line 194 "test.ceu"
    for (;;) {
/* NODE: Stmts 714 */

#line 194 "test.ceu"
    {/* NODE: AwaitExt 713 */

#line 194 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = RulesTest_Awake_TICK_80;

#line 194 "test.ceu"
    	return RET_HALT;
#line 194 "test.ceu"
    case RulesTest_Awake_TICK_80:;

#line 194 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 541 */

#line 195 "test.ceu"
    {/* NODE: Stmts 540 */

#line 195 "test.ceu"
    {/* NODE: If 717 */

#line 195 "test.ceu"
    if ((y()<=30)) {
/* NODE: Block 538 */

#line 196 "test.ceu"
    {/* NODE: Stmts 537 */

#line 196 "test.ceu"
    {/* NODE: CallStmt 535 */

#line 196 "test.ceu"
    printf("up disqualified\n");/* NODE: Break 536 */

#line 197 "test.ceu"
    break;
#line 196 "test.ceu"
    }
#line 196 "test.ceu"
/* CLEAR: Block (196) */
#line 196 "test.ceu"
    }} else {
/* NODE: Nothing 716 */
}

#line 195 "test.ceu"
    }
#line 195 "test.ceu"
/* CLEAR: Block (195) */
#line 195 "test.ceu"
    }
#line 195 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */

#line 194 "test.ceu"
    }
#line 194 "test.ceu"
    }

#line 194 "test.ceu"
/* CLEAR: Loop (194) */
#line 194 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];

#line 194 "test.ceu"
    }
#line 194 "test.ceu"
/* CLEAR: Block (194) */
#line 194 "test.ceu"
    }
#line 194 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */

#line 193 "test.ceu"
/* PAROR JOIN */
#line 193 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_79;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 193 "test.ceu"
case RulesTest_ParOr_sub_2_78:;/* NODE: Block 549 */

#line 201 "test.ceu"
    {/* NODE: Stmts 548 */

#line 201 "test.ceu"
    {/* NODE: AwaitInt 547 */

#line 201 "test.ceu"
    _CEU_NO_547_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = RulesTest_Awake_ok_81;

#line 201 "test.ceu"
    	return RET_HALT;
#line 201 "test.ceu"
    case RulesTest_Awake_ok_81:;

#line 201 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_RulesTest*)_ceu_go->org)->up_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_547_;
    }
#endif

#line 201 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 201 "test.ceu"
    }
#line 201 "test.ceu"
/* CLEAR: Block (201) */
#line 201 "test.ceu"
    }
#line 201 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 6 ]; */

#line 193 "test.ceu"
/* PAROR JOIN */
#line 193 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_79;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 193 "test.ceu"
case RulesTest_ParOr_out_79:;
#line 193 "test.ceu"
/* CLEAR: ParOr (193) */
#line 193 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 5 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_82;
}
return ceu_out_clear(_ceu_go, 6,                     &_ceu_go->org->trls[ 7 ]);

case RulesTest_Clear_82:;

#line 193 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];

#line 186 "test.ceu"
    }
#line 186 "test.ceu"
    _ceu_go->lbl = RulesTest_Block_fin_cnt_84;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 186 "test.ceu"
case RulesTest_Block__fin_83:;
#line 186 "test.ceu"
    if (((CEU_RulesTest*)_ceu_go->org)->__fin_552_1) {
/* NODE: Finally 527 */
/* NODE: Block 526 */

#line 191 "test.ceu"
    {/* NODE: Stmts 525 */

#line 191 "test.ceu"
    {/* NODE: CallStmt 524 */

#line 191 "test.ceu"
    cancel_y();
#line 191 "test.ceu"
    }
#line 191 "test.ceu"
/* CLEAR: Block (191) */
#line 191 "test.ceu"
    }
#line 191 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}

#line 186 "test.ceu"
    	return RET_HALT;
#line 186 "test.ceu"
case RulesTest_Block_fin_cnt_84:;
#line 186 "test.ceu"
/* CLEAR: Block (186) */
#line 186 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_85;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_85:;

#line 186 "test.ceu"
    }
#line 186 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */
} else {
/* NODE: Block 555 */

#line 204 "test.ceu"
    {/* NODE: Stmts 554 */

#line 204 "test.ceu"
    {/* NODE: Break 553 */

#line 204 "test.ceu"
    break;
#line 204 "test.ceu"
    }
#line 204 "test.ceu"
/* CLEAR: Block (204) */
#line 204 "test.ceu"
    }}

#line 185 "test.ceu"
    }
#line 185 "test.ceu"
/* CLEAR: Block (185) */
#line 185 "test.ceu"
    }
#line 185 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 177 "test.ceu"
/* PAROR JOIN */
#line 177 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_75;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 177 "test.ceu"
case RulesTest_ParOr_out_75:;
#line 177 "test.ceu"
/* CLEAR: ParOr (177) */
#line 177 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_86;
}
return ceu_out_clear(_ceu_go, 3,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_86:;

#line 177 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];

#line 177 "test.ceu"
    }
#line 177 "test.ceu"
/* CLEAR: Block (177) */
#line 177 "test.ceu"
    }
#line 177 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}

#line 158 "test.ceu"
    }
#line 158 "test.ceu"
/* CLEAR: Block (158) */
#line 158 "test.ceu"
    }
#line 158 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 150 "test.ceu"
/* PAROR JOIN */
#line 150 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_63;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 150 "test.ceu"
case RulesTest_ParOr_out_63:;
#line 150 "test.ceu"
/* CLEAR: ParOr (150) */
#line 150 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_87;
}
return ceu_out_clear(_ceu_go, 2,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_87:;

#line 150 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 1 ];

#line 150 "test.ceu"
    }
#line 150 "test.ceu"
/* CLEAR: Block (150) */
#line 150 "test.ceu"
    }
#line 150 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */
}

#line 130 "test.ceu"
    }
#line 130 "test.ceu"
/* CLEAR: Block (130) */
#line 130 "test.ceu"
    }
#line 130 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */

#line 122 "test.ceu"
/* PAROR JOIN */
#line 122 "test.ceu"
    _ceu_go->lbl = RulesTest_ParOr_out_51;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 122 "test.ceu"
case RulesTest_ParOr_out_51:;
#line 122 "test.ceu"
/* CLEAR: ParOr (122) */
#line 122 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_88;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_88:;

#line 122 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 122 "test.ceu"
    }
#line 122 "test.ceu"
/* CLEAR: Block (122) */
#line 122 "test.ceu"
    }
#line 122 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}

#line 102 "test.ceu"
    }
#line 102 "test.ceu"
/* CLEAR: Block (102) */
#line 102 "test.ceu"
    }
#line 102 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 101 "test.ceu"
    }

#line 101 "test.ceu"
/* CLEAR: Loop (101) */
#line 101 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_89;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 8 ]);

case RulesTest_Clear_89:;

#line 101 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: CallStmt 578 */

#line 213 "test.ceu"
    assert((x()==30));/* NODE: CallStmt 579 */

#line 214 "test.ceu"
    assert((y()==30));/* NODE: CallStmt 580 */

#line 215 "test.ceu"
    printf("rulestest done\n");/* NODE: EmitInt 583 */

#line 216 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = RulesTest_EmitInt_cont_90;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_RulesTest*)_ceu_go->org);
#endif

#line 216 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case RulesTest_EmitInt_cont_90:;

#line 100 "test.ceu"
    }
#line 100 "test.ceu"
/* CLEAR: Block (100) */
#line 100 "test.ceu"
    }
#line 100 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 97 "test.ceu"
    }
#line 97 "test.ceu"
/* CLEAR: Block (97) */
#line 97 "test.ceu"
    }
#line 97 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 97 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 97 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 5 */

#line 1 "_ceu_cpp_test.ceu.in"
case Class_Main:;
#line 1 "_ceu_cpp_test.ceu.in"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 5;
#endif
/* NODE: Block 729 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 728 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Nothing 612 */
/* NODE: Block 606 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 605 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Dcl_var 602 */
/* NODE: SetBlock 604 */
/* NODE: Block 600 */

#line 1 "_ceu_cpp_test.ceu.in"
    {
#line 1 "_ceu_cpp_test.ceu.in"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Main*)_ceu_go->org)->__lnks_600_1);

#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 599 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 596 */

#line 4 "test.ceu"
    {/* NODE: Stmts 617 */

#line 4 "test.ceu"
    {/* NODE: Nothing 732 */

#line 4 "test.ceu"
    }/* NODE: Stmts 619 */

#line 5 "test.ceu"
    {/* NODE: Nothing 733 */

#line 5 "test.ceu"
    }/* NODE: Stmts 621 */

#line 6 "test.ceu"
    {/* NODE: Nothing 734 */

#line 6 "test.ceu"
    }/* NODE: Stmts 623 */

#line 7 "test.ceu"
    {/* NODE: Nothing 735 */

#line 7 "test.ceu"
    }/* NODE: Stmts 625 */

#line 8 "test.ceu"
    {/* NODE: Nothing 736 */

#line 8 "test.ceu"
    }/* NODE: Stmts 627 */

#line 9 "test.ceu"
    {/* NODE: Nothing 737 */

#line 9 "test.ceu"
    }/* NODE: Stmts 629 */

#line 10 "test.ceu"
    {/* NODE: Nothing 738 */

#line 10 "test.ceu"
    }/* NODE: Stmts 631 */

#line 12 "test.ceu"
    {/* NODE: Nothing 739 */

#line 12 "test.ceu"
    }/* NODE: Stmts 633 */

#line 13 "test.ceu"
    {/* NODE: Nothing 740 */

#line 13 "test.ceu"
    }/* NODE: Stmts 635 */

#line 14 "test.ceu"
    {/* NODE: Nothing 741 */

#line 14 "test.ceu"
    }/* NODE: Stmts 637 */

#line 15 "test.ceu"
    {/* NODE: Nothing 742 */

#line 15 "test.ceu"
    }/* NODE: Nothing 743 */
/* NODE: Nothing 744 */
/* NODE: Nothing 745 */
/* NODE: Nothing 746 */
/* NODE: Nothing 747 */
/* NODE: Nothing 748 */
/* NODE: AwaitExt 588 */

#line 220 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_START;
    _ceu_go->trl->lbl = Main_Awake_START_94;

#line 220 "test.ceu"
    	return RET_HALT;
#line 220 "test.ceu"
    case Main_Awake_START_94:;

#line 220 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Stmts 723 */

#line 223 "test.ceu"
    {/* NODE: Dcl_var 722 */

#line 223 "test.ceu"
/* start org: to_test */
#line 223 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->to_test)),9,Class_RulesTest,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 223 "test.ceu"
        }
}

#line 223 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Main_Start_cnt_95,((tceu_org*) (&((CEU_Main*)_ceu_go->org)->to_test)),Class_RulesTest);
case Main_Start_cnt_95:;

#line 223 "test.ceu"
    }/* NODE: AwaitInt 593 */

#line 224 "test.ceu"
    _CEU_NO_593_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Main_Awake_ok_96;

#line 224 "test.ceu"
    	return RET_HALT;
#line 224 "test.ceu"
    case Main_Awake_ok_96:;

#line 224 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Main*)_ceu_go->org)->to_test) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_593_;
    }
#endif

#line 224 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Stmts 727 */

#line 226 "test.ceu"
    {/* NODE: SetExp 725 */

#line 226 "test.ceu"
/* SET: _ret */
#line 226 "test.ceu"
    ((CEU_Main*)_ceu_go->org)->_ret_0 = 0;
#line 226 "test.ceu"
    #ifdef CEU_RET
    _ceu_app->ret = ((CEU_Main*)_ceu_go->org)->_ret_0;
#endif
/* NODE: Escape 726 */

#line 226 "test.ceu"
    _ceu_go->lbl = Main_Set_out_93;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 226 "test.ceu"
    }
#line 4 "test.ceu"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    	return RET_HALT;
#line 1 "_ceu_cpp_test.ceu.in"
case Main_Set_out_93:;
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: SetBlock (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Main_Clear_98;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Main_Clear_98:;

#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 1 "_ceu_cpp_test.ceu.in"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 1 "_ceu_cpp_test.ceu.in"
    	return RET_END;
    }
    return RET_HALT;    /* TODO: should never be reached anyways */
}

static void ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
#ifdef CEU_LUA
    app->lua = luaL_newstate();
    /* TODO: lua_close(CEU_L); */
    assert(app->lua != NULL);
    luaL_openlibs(app->lua);
    lua_atpanic(app->lua, ceu_lua_atpanic);
#endif

#ifdef CEU_OS

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS */

#ifndef CEU_OS
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(app, app->data, CEU_NTRAILS, Class_Main, 0,
#ifdef CEU_NEWS
                0,
#endif
                NULL, 0);
    ceu_out_go(app, CEU_IN__INIT, CEU_EVTP((void*)NULL));
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
}
#endif

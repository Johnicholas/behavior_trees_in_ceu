/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "test.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_INTS
#define CEU_EXTS
#define CEU_ORGS
#define CEU_RET
#define CEU_GOTO
#define CEU_CLEAR
#define CEU_IFCS
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s16 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s8 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 3

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#define CEU_IN__NONE 0
#define CEU_IN__STK 255
#define CEU_IN__ORG 254
#define CEU_IN__ORG_PSED 253
#define CEU_IN__INIT 252
#define CEU_IN__CLEAR 251
#define CEU_IN__WCLOCK 250
#define CEU_IN__ASYNC 249
#define CEU_IN__THREAD 248
#define CEU_IN_START 247
#define CEU_IN_X_DONE 246
#define CEU_IN_Y_DONE 245
#define CEU_IN_TICK 244
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_assert
#define CEU_FUN_printf
#define CEU_FUN_cancel_x
#define CEU_FUN_move_y
#define CEU_FUN_move_x
#define CEU_FUN_x
#define CEU_FUN_y
#define CEU_FUN_cancel_y
   /* CEU_FUN_ */


/* class definitions */
/*
// TODO: host language to have access to classes
=== CLSS_DEFS ===
*/

#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

/* TODO: #ifdef CEU_INTS: seqno, stki, CEU_STK */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (void* vv) : ptr(vv) {}
    tceu_evtp (s32   vv) : dt(vv)  {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_OS
#ifdef __AVR
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <assert.h>
#endif

#if defined(CEU_OS) || defined(CEU_DEBUG)
#include <stdlib.h>     /* malloc/free, exit */
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic (lua_State* lua) {
#ifdef CEU_DEBUG
    fprintf(stderr, "LUA_ATPANIC: %s\n",
            lua_tostring(lua,-1));
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS)
void* ceu_sys_malloc (size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (_ceu_dyns_ >= CEU_MAX_DYNS)
        return NULL;
    _ceu_dyns_++;           /* assumes no malloc fails */
#endif
#endif
    return malloc(size);
}

void ceu_sys_free (void* ptr) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (ptr != NULL)
        _ceu_dyns_--;
#endif
#endif
    free(ptr);
}
#endif

/**********************************************************************/

/* TODO: ifndef CEU_OS? */
int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

/* TODO: CEU_OS */
#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnk;
    lnk[0].nxt = (tceu_org*) &lnk[1];
    lnk[1].prv = (tceu_org*) &lnk[0];
    lnk[1].nxt =  org;
    lnk[1].n   =  0;    /* marks end of linked list */
    lnk[1].lnk =  idx+1;
}

int ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org) {
    /* hold current blk trail: set to my continuation */
    _ceu_go->trl->evt = CEU_IN__STK;
    _ceu_go->trl->lbl = lbl_cnt;
    _ceu_go->trl->stk = _ceu_go->stki;

    _ceu_go->stk[_ceu_go->stki  ].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _ceu_go->stk[_ceu_go->stki  ].evto = _ceu_go->evto;
#endif
#endif
    _ceu_go->stk[_ceu_go->stki++].evt  = _ceu_go->evt;

    /* switch to ORG */

    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl_org;
    org->trls[0].stk = _ceu_go->stki;

    _ceu_go->org  = org;
#ifdef CEU_CLEAR
    _ceu_go->stop = &_ceu_go->org->trls[_ceu_go->org->n]; /* don't follow the up link */
#endif
    return RET_ORG;
}

#endif

void ceu_sys_org (tceu_org* org, int n, int lbl, int seqno,
#ifdef CEU_NEWS
                  int isDyn,
#endif
                  tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS)
    org->n = n;
    org->isAlive = 1;
#endif
#ifdef CEU_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_sys_org(a,b,c,d,e,f) ceu_sys_org(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_tmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min > t) {
        app->wclk_min = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late_;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp_ || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min_ > t) {
        app->wclk_min_ = t;
#ifdef ceu_out_wclock_set_
        ceu_out_wclock_set_(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_CLEAR
/* TODO: CEU_OS map (ceu_out_* )*/
int ceu_sys_clear (tceu_go* go, int start, void* stop) {
    go->stk[go->stki  ].evtp = go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    go->stk[go->stki  ].evto = go->evto;
#endif
#endif
    go->stk[go->stki++].evt  = go->evt;
    go->trl  = &go->org->trls[start];
    go->stop = stop;
    go->evt = CEU_IN__CLEAR;
    return RET_TRL;
}
#endif

/* TODO: ifndef CEU_OS? */
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */

void ceu_sys_go (tceu_app* app, int evt, tceu_evtp evtp)
{
    tceu_go go;

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            if (app->wclk_min <= evtp.dt) {
                app->wclk_late = evtp.dt - app->wclk_min;
            }
            app->wclk_min_tmp = app->wclk_min;
            app->wclk_min     = CEU_WCLOCK_INACTIVE;
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            if (app->wclk_min_ <= evtp.dt) {
                app->wclk_late_ = evtp.dt - app->wclk_min_;
            }
            app->wclk_min_tmp_ = app->wclk_min_;
            app->wclk_min_     = CEU_WCLOCK_INACTIVE;
            break;
#endif
#endif
    }

    go.evt  = evt;
    go.evtp = evtp;
    go.stki = 0;
#ifdef CEU_CLEAR
    go.stop = NULL;     /* traverse all (don't stop) */
#endif

#ifdef CEU_NEWS
    tceu_org* lst_free = NULL;  /* "to free" list (only on reaction end) */
#endif

    app->seqno++;

    for (;;)    /* STACK */
    {
#ifdef CEU_DEBUG
        assert(go.stki < 32000);
#endif
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        go.org = app->data;    /* on pop(), always restart */
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_GO_CALL_ORG_:
#endif
        /* restart from org->trls[0] */
        go.trl = &go.org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_GO_CALL_TRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#if defined(CEU_ORGS) || defined(CEU_OS)
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", app->seqno,
                go.evt, go.stki, go.org, go.org->n, go.org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", app->seqno,
                go.evt, go.stki, CEU_NTRAILS);
#endif
#endif

        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
#ifdef CEU_CLEAR
            if (go.trl == go.stop) {    /* bounded trail traversal? */
                go.stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* go.org has been traversed to the end? */
            if (go.trl ==
                &go.org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS)
                    go.org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (go.org == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = go.org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (go.org->n == 0) ?
                                         ((tceu_org_lnk*)go.org)->lnk : 0
                                      ];

                    /* org has been traversed and *CLEARED* to the end? */
                    if (go.evt == CEU_IN__CLEAR) {

#ifdef CEU_ORGS_WATCHING
                        /* TODO: stack will overflow!!! T[9999] */
                        /* emit this.ok */
                        /*go.stk[go.stki].evtp = ?*/
                        go.stk[go.stki].evto = go.org;
                        go.stk[go.stki].evt  = 1;   /* TODO: 1==_ok */
                        go.stki++;
#endif

#ifdef CEU_NEWS
                        if ( go.org->n != 0 /* TODO: avoids LNKs (must be before isDyn */
                        &&   go.org->isDyn ) {
                            /* re-link PRV <-> NXT */
                            go.org->prv->nxt = go.org->nxt;
                            go.org->nxt->prv = go.org->prv;

                            /* Should be freed if (malloc'ed) or
                             *                    (pool still on scope):
                             * - malloc'ed:     (org->pool==NULL)
                             * - pool on scope: (!org->isAlive)
                             */
/* TODO: what if both happens at the same time (body and pool terminate?) */
#ifdef CEU_NEWS_POOL
                            if (!go.org->isAlive
#ifdef CEU_NEWS_MALLOC
                            || go.org->pool == NULL
#endif
                            )
#else
                            /* malloc'ed for sure, no if required */
#endif
                            {
                                tceu_org* nxt = lst_free;
                                go.org->nxt_free = NULL;    /* no next element */
                                if (lst_free == NULL) {
                                    lst_free = go.org;      /* new first element */
                                } else {
                                    while (nxt->nxt_free != NULL) {
                                        nxt = nxt->nxt_free; /* find last element */
                                    }
                                    nxt->nxt_free = go.org;  /* put after that */
                                }
                            }
                            go.org->isAlive = 0;

                            /* explicit free(me) or end of spawn */
                            if (go.stop == go.org)
                                break;  /* pop stack */
                        }
#else
                        go.org->isAlive = 0;
#endif  /* CEU_NEWS */
                    }

                    go.org = _org;
                    go.trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, go.org go.trl);*/
                    goto _CEU_GO_CALL_TRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (go.trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=%p->%p\n",
                    go.trl, go.trl->evt,
                    &go.trl->lnks[0], &go.trl->lnks[1]);
else
#endif
    fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    go.trl, go.trl->evt, go.trl->seqno, go.trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (go.trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (go.trl->evt==CEU_IN__ORG_PSED && go.evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    go.org = go.trl->lnks[0].nxt;   /* jump FST */
                    if (go.evt == CEU_IN__CLEAR) {
                        go.trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_GO_CALL_ORG_;
                }
#endif /* CEU_ORGS */

                switch (go.evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (go.trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_GO_;
                        go.trl->evt = CEU_IN__NONE;
                        goto _CEU_GO_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (go.trl->evt==CEU_IN__STK && go.trl->stk==go.stki)
                ||
                    (go.trl->evt==go.evt && go.trl->seqno!=app->seqno)
                    /* evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=Â´ intead of `<Â´ due to u8 overflow */
                ) ) {
                    goto _CEU_GO_NEXT_;
                }
_CEU_GO_GO_:
                /* execute this trail */
                go.trl->evt   = CEU_IN__NONE;
                go.trl->seqno = app->seqno;   /* don't awake again */
                go.lbl = go.trl->lbl;
            }

            {
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif
                /*** CODE ***/
                int _ret = app->code(app, &go);
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_END:
#if defined(CEU_RET) || defined(CEU_OS)
                        app->isAlive = 0;
                        CEU_GC = 1;
#endif
                        goto _CEU_GO_QUIT_;
/*
                    case RET_GOTO:
                        goto _CEU_GOTO_;
*/
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_TRL:
                        goto _CEU_GO_CALL_TRL_;
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
                    case RET_ORG:
                        goto _CEU_GO_CALL_ORG_;
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
                    default:
                        break;
                }
            }
_CEU_GO_NEXT_:
            /* go.trl!=CEU_IN__ORG guaranteed here */
            if (go.trl->evt!=CEU_IN__STK && go.trl->seqno!=app->seqno)
                go.trl->seqno = app->seqno-1;   /* keeps the gap tight */
            go.trl++;
        }

        if (go.stki == 0) {
            break;      /* reaction has terminated */
        }
        go.evtp = go.stk[--go.stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        go.evto = (tceu_org*) go.stk[  go.stki].evto;
#endif
#endif
        go.evt  = go.stk[  go.stki].evt;
    }

_CEU_GO_QUIT_:;

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min_ != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min_);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late_ = 0;
    }
#endif
#endif

    /* free all orgs on "lst_free" on reaction termination */
#ifdef CEU_NEWS
    while (lst_free != NULL) {
        tceu_org* org = lst_free;
        lst_free = org->nxt_free;
#if    defined(CEU_NEWS_POOL) && !defined(CEU_NEWS_MALLOC)
        ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif  defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        if (org->pool == NULL)
            ceu_sys_free(org);
        else
            ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif !defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        ceu_sys_free(org);
#endif
    }
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS)
    if (app->isAlive)
#endif
        ceu_sys_go(app, CEU_IN_OS_START, CEU_EVTP((void*)NULL));
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    assert(_ceu_dyns_ == 0);
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

#ifdef CEU_OS

/* SYS_VECTOR
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_sys_malloc,
    (void*) &ceu_sys_free,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_clear,
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX];
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                       int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX)
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;

        if (sz == 0) {
            /* "param" is self-contained */
            qu->param = param;
        } else {
            /* "param" points to "buf" */
            qu->param.ptr = qu->buf;
            memcpy(qu->buf, buf, sz);
        }
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                  int sz, byte* buf) {
    return ceu_sys_queue_put(app, evt, param, sz, buf);
}

tceu_evtp ceu_sys_call (tceu_app* app, tceu_nevt evt, tceu_evtp param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt)
            continue;
#if defined(CEU_OS) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        tceu_evtp ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return CEU_EVTP((void*)NULL);
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk)
			cur = cur->nxt;
		if (cur->nxt != NULL)
            cur->nxt = lnk->nxt;
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_free(lnk);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive)
                _ceu_sys_unlink(cur);
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_free(app->data);
            ceu_sys_free(app);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->param);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->param);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init);
#endif

    tceu_app* app = (tceu_app*) ceu_sys_malloc(sizeof(tceu_app));
    if (app == NULL)
        return NULL;

    app->data = (tceu_org*) ceu_sys_malloc(size);
    if (app->data == NULL)
        return NULL;

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, CEU_EVTP((void*)NULL), 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_malloc(sizeof(tceu_lnk));
    if (lnk == NULL)
        return 0;

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif  /* CEU_OS */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif
#ifdef CEU_THREADS
#include <assert.h>
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (12)
#endif

/* native code from the Main class */


/* class definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

typedef void CEU_Executor;



typedef struct CEU_MoveX {
  struct tceu_org org;
  tceu_trl trls_[ 3 ];
  struct { /* BLOCK ln=21 */
    #line 23 "test.ceu"
int distance;
    union {
      struct { /* BLOCK ln=25 */
      u8 __fin_209_1: 1;
        #line 25 "test.ceu"
bool cancel;
        union {
          union {
          };
              struct { /* BLOCK ln=27 */
                union {
                    struct { /* BLOCK ln=28 */
                      union {
                      };
                    };
                };
              };
        };
      };
    };
  };

} CEU_MoveX;



typedef struct CEU_MoveY {
  struct tceu_org org;
  tceu_trl trls_[ 3 ];
  struct { /* BLOCK ln=40 */
    #line 42 "test.ceu"
int distance;
    union {
      struct { /* BLOCK ln=44 */
      u8 __fin_240_1: 1;
        #line 44 "test.ceu"
bool cancel;
        union {
          union {
          };
              struct { /* BLOCK ln=46 */
                union {
                    struct { /* BLOCK ln=47 */
                      union {
                      };
                    };
                };
              };
        };
      };
    };
  };

} CEU_MoveY;



typedef struct CEU_BoxTest {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=59 */
    union {
      struct { /* BLOCK ln=62 */
        #line 63 "test.ceu"
CEU_MoveX right;
      tceu_org_lnk __lnks_300_1[2];
        #line 71 "test.ceu"
CEU_MoveX left;
      tceu_org_lnk __lnks_300_3[2];
        #line 67 "test.ceu"
CEU_MoveY down;
      tceu_org_lnk __lnks_300_2[2];
        #line 75 "test.ceu"
CEU_MoveY up;
      tceu_org_lnk __lnks_300_4[2];
        union {
              struct { /* BLOCK ln=64 */
                union {
                };
              };
              struct { /* BLOCK ln=68 */
                union {
                };
              };
              struct { /* BLOCK ln=72 */
                union {
                };
              };
              struct { /* BLOCK ln=76 */
                union {
                };
              };
        };
      };
    };
  };

} CEU_BoxTest;



typedef struct CEU_DiagonalTest {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=83 */
    union {
      struct { /* BLOCK ln=86 */
        union {
          struct {
            struct { /* BLOCK ln=88 */
              #line 88 "test.ceu"
CEU_MoveX right_2;
            tceu_org_lnk __lnks_318_1[2];
              union {
                    struct { /* BLOCK ln=89 */
                      union {
                      };
                    };
              };
            };
            struct { /* BLOCK ln=93 */
              #line 93 "test.ceu"
CEU_MoveY down_3;
            tceu_org_lnk __lnks_332_4[2];
              union {
                    struct { /* BLOCK ln=94 */
                      union {
                      };
                    };
              };
            };
            u8 __and_333_1: 1;
            u8 __and_333_2: 1;
          };
          struct {
            struct { /* BLOCK ln=99 */
              #line 99 "test.ceu"
CEU_MoveX left_4;
            tceu_org_lnk __lnks_348_1[2];
              union {
                    struct { /* BLOCK ln=100 */
                      union {
                      };
                    };
              };
            };
            struct { /* BLOCK ln=104 */
              #line 104 "test.ceu"
CEU_MoveY up_5;
            tceu_org_lnk __lnks_363_4[2];
              union {
                    struct { /* BLOCK ln=105 */
                      union {
                      };
                    };
              };
            };
            u8 __and_364_1: 1;
            u8 __and_364_2: 1;
          };
        };
      };
    };
  };

} CEU_DiagonalTest;



typedef struct CEU_Halfplane {
  struct tceu_org org;
  tceu_trl trls_[ 2 ];
  struct { /* BLOCK ln=113 */
    #line 115 "test.ceu"
int xcoeff;
    #line 116 "test.ceu"
int ycoeff;
    #line 117 "test.ceu"
int offset;
    union {
      struct { /* BLOCK ln=119 */
        union {
            union {
              struct { /* BLOCK ln=120 */
                union {
                    struct { /* BLOCK ln=121 */
                      union {
                      };
                    };
                };
              };
            };
        };
      };
    };
  };

} CEU_Halfplane;



typedef struct CEU_Skip {
  struct tceu_org org;
  tceu_trl trls_[ 2 ];
  struct { /* BLOCK ln=126 */
    union {
      struct { /* BLOCK ln=129 */
        union {
        };
      };
    };
  };

} CEU_Skip;



typedef struct CEU_Quux {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=132 */
    union {
      struct { /* BLOCK ln=135 */
        union {
            struct { /* BLOCK ln=136 */
              union {
                struct {
                  struct { /* BLOCK ln=137 */
                    #line 138 "test.ceu"
CEU_MoveY up_2;
                  tceu_org_lnk __lnks_442_1[2];
                    union {
                          struct { /* BLOCK ln=139 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=144 */
                    #line 144 "test.ceu"
CEU_Halfplane guard_3;
                  tceu_org_lnk __lnks_465_4[2];
                    union {
                          struct { /* BLOCK ln=145 */
                            union {
                            };
                          };
                    };
                  };
                };
              };
            };
            struct { /* BLOCK ln=153 */
              union {
                struct {
                  struct { /* BLOCK ln=154 */
                    #line 154 "test.ceu"
CEU_Halfplane guard_4;
                  tceu_org_lnk __lnks_491_1[2];
                    union {
                          struct { /* BLOCK ln=155 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=162 */
                    #line 162 "test.ceu"
CEU_Skip default_5;
                  tceu_org_lnk __lnks_498_4[2];
                    union {
                      union {
                      };
                    };
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Quux;



typedef struct CEU_Qux {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=169 */
    union {
      struct { /* BLOCK ln=172 */
        union {
            struct { /* BLOCK ln=173 */
              union {
                struct {
                  struct { /* BLOCK ln=174 */
                    #line 175 "test.ceu"
CEU_MoveY move_2;
                  tceu_org_lnk __lnks_535_1[2];
                    union {
                          struct { /* BLOCK ln=176 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=181 */
                    #line 181 "test.ceu"
CEU_Halfplane guard_3;
                  tceu_org_lnk __lnks_558_4[2];
                    union {
                          struct { /* BLOCK ln=182 */
                            union {
                            };
                          };
                    };
                  };
                };
              };
            };
            struct { /* BLOCK ln=190 */
              union {
                struct {
                  struct { /* BLOCK ln=191 */
                    #line 191 "test.ceu"
CEU_Halfplane guard_4;
                  tceu_org_lnk __lnks_584_1[2];
                    union {
                          struct { /* BLOCK ln=192 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=199 */
                    #line 199 "test.ceu"
CEU_Quux default_5;
                  tceu_org_lnk __lnks_591_4[2];
                    union {
                      union {
                      };
                    };
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Qux;



typedef struct CEU_Bar {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=207 */
    union {
      struct { /* BLOCK ln=210 */
        union {
            struct { /* BLOCK ln=211 */
              union {
                struct {
                  struct { /* BLOCK ln=212 */
                    #line 213 "test.ceu"
CEU_MoveX move_2;
                  tceu_org_lnk __lnks_628_1[2];
                    union {
                          struct { /* BLOCK ln=214 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=219 */
                    #line 219 "test.ceu"
CEU_Halfplane guard_3;
                  tceu_org_lnk __lnks_651_4[2];
                    union {
                          struct { /* BLOCK ln=220 */
                            union {
                            };
                          };
                    };
                  };
                };
              };
            };
            struct { /* BLOCK ln=228 */
              union {
                struct {
                  struct { /* BLOCK ln=229 */
                    #line 229 "test.ceu"
CEU_Halfplane guard_4;
                  tceu_org_lnk __lnks_677_1[2];
                    union {
                          struct { /* BLOCK ln=230 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=237 */
                    #line 237 "test.ceu"
CEU_Qux default_5;
                  tceu_org_lnk __lnks_684_4[2];
                    union {
                      union {
                      };
                    };
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Bar;



typedef struct CEU_Foo {
  struct tceu_org org;
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=244 */
    union {
      struct { /* BLOCK ln=247 */
        union {
            struct { /* BLOCK ln=248 */
              union {
                struct {
                  struct { /* BLOCK ln=249 */
                    #line 250 "test.ceu"
CEU_MoveX go_right_2;
                  tceu_org_lnk __lnks_721_1[2];
                    union {
                          struct { /* BLOCK ln=251 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=256 */
                    #line 256 "test.ceu"
CEU_Halfplane guard_3;
                  tceu_org_lnk __lnks_746_4[2];
                    union {
                          struct { /* BLOCK ln=257 */
                            union {
                            };
                          };
                    };
                  };
                };
              };
            };
            struct { /* BLOCK ln=265 */
              union {
                struct {
                  struct { /* BLOCK ln=266 */
                    #line 266 "test.ceu"
CEU_Halfplane guard_4;
                  tceu_org_lnk __lnks_772_1[2];
                    union {
                          struct { /* BLOCK ln=267 */
                            union {
                            };
                          };
                    };
                  };
                  struct { /* BLOCK ln=274 */
                    #line 274 "test.ceu"
CEU_Bar default_5;
                  tceu_org_lnk __lnks_779_4[2];
                    union {
                      union {
                      };
                    };
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Foo;



typedef struct CEU_RulesTest {
  struct tceu_org org;
  tceu_trl trls_[ 4 ];
  struct { /* BLOCK ln=281 */
    union {
      struct { /* BLOCK ln=284 */
        union {
            struct { /* BLOCK ln=286 */
              union {
                  struct { /* BLOCK ln=288 */
                    union {
                    };
                  };
                  struct { /* BLOCK ln=290 */
                    #line 290 "test.ceu"
CEU_Foo body_2;
                  tceu_org_lnk __lnks_814_1[2];
                    union {
                      union {
                      };
                    };
                  };
              };
            };
        };
      };
    };
  };

} CEU_RulesTest;


typedef struct CEU_Main {
  struct tceu_org org;
  tceu_trl trls_[ 3 ];
  struct { /* BLOCK ln=1 */
    union {
      struct { /* BLOCK ln=1 */
        #line 1 "_ceu_cpp_test.ceu.in"
int _ret_0;
        union {
            struct { /* BLOCK ln=1 */
              #line 304 "test.ceu"
CEU_RulesTest to_test;
            tceu_org_lnk __lnks_841_1[2];
              union {
                union {
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                };
              };
            };
        };
      };
    };
  };

} CEU_Main;




/* goto labels */
enum {
    MoveX_Awake_X_DONE_0 = 0,
    MoveX_EmitInt_cont_1 = 1,
    MoveX_Block__fin_2 = 2,
    MoveX_Block_fin_cnt_3 = 3,
    MoveX_Clear_4 = 4,
    Class_MoveX = 5,
    MoveX_Class_free_MoveX_6 = 6,
    MoveY_Awake_Y_DONE_7 = 7,
    MoveY_EmitInt_cont_8 = 8,
    MoveY_Block__fin_9 = 9,
    MoveY_Block_fin_cnt_10 = 10,
    MoveY_Clear_11 = 11,
    Class_MoveY = 12,
    MoveY_Class_free_MoveY_13 = 13,
    BoxTest_Start_cnt_14 = 14,
    BoxTest_Awake_ok_15 = 15,
    BoxTest_Start_cnt_16 = 16,
    BoxTest_Awake_ok_17 = 17,
    BoxTest_Start_cnt_18 = 18,
    BoxTest_Awake_ok_19 = 19,
    BoxTest_Start_cnt_20 = 20,
    BoxTest_Awake_ok_21 = 21,
    BoxTest_EmitInt_cont_22 = 22,
    BoxTest_Clear_23 = 23,
    Class_BoxTest = 24,
    BoxTest_Class_free_BoxTest_25 = 25,
    DiagonalTest_ParAnd_sub_2_26 = 26,
    DiagonalTest_ParAnd_chk_27 = 27,
    DiagonalTest_ParAnd_out_28 = 28,
    DiagonalTest_Start_cnt_29 = 29,
    DiagonalTest_Awake_ok_30 = 30,
    DiagonalTest_Clear_31 = 31,
    DiagonalTest_Start_cnt_32 = 32,
    DiagonalTest_Awake_ok_33 = 33,
    DiagonalTest_Clear_34 = 34,
    DiagonalTest_ParAnd_sub_2_35 = 35,
    DiagonalTest_ParAnd_chk_36 = 36,
    DiagonalTest_ParAnd_out_37 = 37,
    DiagonalTest_Start_cnt_38 = 38,
    DiagonalTest_Awake_ok_39 = 39,
    DiagonalTest_Clear_40 = 40,
    DiagonalTest_Start_cnt_41 = 41,
    DiagonalTest_Awake_ok_42 = 42,
    DiagonalTest_Clear_43 = 43,
    DiagonalTest_EmitInt_cont_44 = 44,
    Class_DiagonalTest = 45,
    DiagonalTest_Class_free_DiagonalTest_46 = 46,
    Halfplane_Awake_TICK_47 = 47,
    Halfplane_EmitInt_cont_48 = 48,
    Class_Halfplane = 49,
    Halfplane_Class_free_Halfplane_50 = 50,
    Skip_EmitInt_cont_51 = 51,
    Class_Skip = 52,
    Skip_Class_free_Skip_53 = 53,
    Quux_ParOr_sub_2_54 = 54,
    Quux_ParOr_out_55 = 55,
    Quux_Start_cnt_56 = 56,
    Quux_Awake_ok_57 = 57,
    Quux_Clear_58 = 58,
    Quux_Start_cnt_59 = 59,
    Quux_Awake_ok_60 = 60,
    Quux_Clear_61 = 61,
    Quux_Clear_62 = 62,
    Quux_ParOr_sub_2_63 = 63,
    Quux_ParOr_out_64 = 64,
    Quux_Start_cnt_65 = 65,
    Quux_Awake_ok_66 = 66,
    Quux_Clear_67 = 67,
    Quux_Start_cnt_68 = 68,
    Quux_Awake_ok_69 = 69,
    Quux_Clear_70 = 70,
    Quux_Clear_71 = 71,
    Quux_EmitInt_cont_72 = 72,
    Class_Quux = 73,
    Quux_Class_free_Quux_74 = 74,
    Qux_ParOr_sub_2_75 = 75,
    Qux_ParOr_out_76 = 76,
    Qux_Start_cnt_77 = 77,
    Qux_Awake_ok_78 = 78,
    Qux_Clear_79 = 79,
    Qux_Start_cnt_80 = 80,
    Qux_Awake_ok_81 = 81,
    Qux_Clear_82 = 82,
    Qux_Clear_83 = 83,
    Qux_ParOr_sub_2_84 = 84,
    Qux_ParOr_out_85 = 85,
    Qux_Start_cnt_86 = 86,
    Qux_Awake_ok_87 = 87,
    Qux_Clear_88 = 88,
    Qux_Start_cnt_89 = 89,
    Qux_Awake_ok_90 = 90,
    Qux_Clear_91 = 91,
    Qux_Clear_92 = 92,
    Qux_EmitInt_cont_93 = 93,
    Class_Qux = 94,
    Qux_Class_free_Qux_95 = 95,
    Bar_ParOr_sub_2_96 = 96,
    Bar_ParOr_out_97 = 97,
    Bar_Start_cnt_98 = 98,
    Bar_Awake_ok_99 = 99,
    Bar_Clear_100 = 100,
    Bar_Start_cnt_101 = 101,
    Bar_Awake_ok_102 = 102,
    Bar_Clear_103 = 103,
    Bar_Clear_104 = 104,
    Bar_ParOr_sub_2_105 = 105,
    Bar_ParOr_out_106 = 106,
    Bar_Start_cnt_107 = 107,
    Bar_Awake_ok_108 = 108,
    Bar_Clear_109 = 109,
    Bar_Start_cnt_110 = 110,
    Bar_Awake_ok_111 = 111,
    Bar_Clear_112 = 112,
    Bar_Clear_113 = 113,
    Bar_EmitInt_cont_114 = 114,
    Class_Bar = 115,
    Bar_Class_free_Bar_116 = 116,
    Foo_ParOr_sub_2_117 = 117,
    Foo_ParOr_out_118 = 118,
    Foo_Start_cnt_119 = 119,
    Foo_Awake_ok_120 = 120,
    Foo_Clear_121 = 121,
    Foo_Start_cnt_122 = 122,
    Foo_Awake_ok_123 = 123,
    Foo_Clear_124 = 124,
    Foo_Clear_125 = 125,
    Foo_ParOr_sub_2_126 = 126,
    Foo_ParOr_out_127 = 127,
    Foo_Start_cnt_128 = 128,
    Foo_Awake_ok_129 = 129,
    Foo_Clear_130 = 130,
    Foo_Start_cnt_131 = 131,
    Foo_Awake_ok_132 = 132,
    Foo_Clear_133 = 133,
    Foo_Clear_134 = 134,
    Foo_EmitInt_cont_135 = 135,
    Class_Foo = 136,
    Foo_Class_free_Foo_137 = 137,
    RulesTest_Start_cnt_138 = 138,
    RulesTest_Awake_ok_139 = 139,
    RulesTest_Clear_140 = 140,
    RulesTest_EmitInt_cont_141 = 141,
    Class_RulesTest = 142,
    RulesTest_Class_free_RulesTest_143 = 143,
    Main_Set_out_144 = 144,
    Main_Awake_START_145 = 145,
    Main_Start_cnt_146 = 146,
    Main_Awake_ok_147 = 147,
    Main_Clear_148 = 148,
    Main_Clear_149 = 149,
    Class_Main = 150,
    Main_Class_free_Main_151 = 151,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][1];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][0];
    u16       ifcs_evts[CEU_NCLS][4];
    void*     ifcs_funs[CEU_NCLS][0];
    tceu_ntrl ifcs_trls[CEU_NCLS][0];
#endif
} _tceu_app;

/* TODO: remove from RAM */
static _tceu_app _CEU_APP = {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    {
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{1},
		{0}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{}
    },
    {
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,2},
		{0,0,1,0}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{}
    },
    {
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{},
		{}
    }
#endif
};

/**********************************************************************/

#ifndef CEU_OS
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_252 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 252 */
/* NODE: Block 251 */

#line 64 "test.ceu"
    {/* NODE: Stmts 250 */

#line 64 "test.ceu"
    {/* NODE: SetExp 917 */

#line 64 "test.ceu"
/* SET: . */
#line 64 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = 10;
#line 64 "test.ceu"
    }
#line 64 "test.ceu"
/* CLEAR: Block (64) */
#line 64 "test.ceu"
    }
#line 64 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_264 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 264 */
/* NODE: Block 263 */

#line 68 "test.ceu"
    {/* NODE: Stmts 262 */

#line 68 "test.ceu"
    {/* NODE: SetExp 918 */

#line 68 "test.ceu"
/* SET: . */
#line 68 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = 10;
#line 68 "test.ceu"
    }
#line 68 "test.ceu"
/* CLEAR: Block (68) */
#line 68 "test.ceu"
    }
#line 68 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_277 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 277 */
/* NODE: Block 276 */

#line 72 "test.ceu"
    {/* NODE: Stmts 275 */

#line 72 "test.ceu"
    {/* NODE: SetExp 919 */

#line 72 "test.ceu"
/* SET: . */
#line 72 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (-10);
#line 72 "test.ceu"
    }
#line 72 "test.ceu"
/* CLEAR: Block (72) */
#line 72 "test.ceu"
    }
#line 72 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_290 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 290 */
/* NODE: Block 289 */

#line 76 "test.ceu"
    {/* NODE: Stmts 288 */

#line 76 "test.ceu"
    {/* NODE: SetExp 920 */

#line 76 "test.ceu"
/* SET: . */
#line 76 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (-10);
#line 76 "test.ceu"
    }
#line 76 "test.ceu"
/* CLEAR: Block (76) */
#line 76 "test.ceu"
    }
#line 76 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_312 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 312 */
/* NODE: Block 311 */

#line 89 "test.ceu"
    {/* NODE: Stmts 310 */

#line 89 "test.ceu"
    {/* NODE: SetExp 926 */

#line 89 "test.ceu"
/* SET: . */
#line 89 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = 20;
#line 89 "test.ceu"
    }
#line 89 "test.ceu"
/* CLEAR: Block (89) */
#line 89 "test.ceu"
    }
#line 89 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_326 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 326 */
/* NODE: Block 325 */

#line 94 "test.ceu"
    {/* NODE: Stmts 324 */

#line 94 "test.ceu"
    {/* NODE: SetExp 927 */

#line 94 "test.ceu"
/* SET: . */
#line 94 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = 20;
#line 94 "test.ceu"
    }
#line 94 "test.ceu"
/* CLEAR: Block (94) */
#line 94 "test.ceu"
    }
#line 94 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_342 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 342 */
/* NODE: Block 341 */

#line 100 "test.ceu"
    {/* NODE: Stmts 340 */

#line 100 "test.ceu"
    {/* NODE: SetExp 928 */

#line 100 "test.ceu"
/* SET: . */
#line 100 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (-20);
#line 100 "test.ceu"
    }
#line 100 "test.ceu"
/* CLEAR: Block (100) */
#line 100 "test.ceu"
    }
#line 100 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_357 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 357 */
/* NODE: Block 356 */

#line 105 "test.ceu"
    {/* NODE: Stmts 355 */

#line 105 "test.ceu"
    {/* NODE: SetExp 929 */

#line 105 "test.ceu"
/* SET: . */
#line 105 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (-20);
#line 105 "test.ceu"
    }
#line 105 "test.ceu"
/* CLEAR: Block (105) */
#line 105 "test.ceu"
    }
#line 105 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_435 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 435 */
/* NODE: Block 434 */

#line 139 "test.ceu"
    {/* NODE: Stmts 433 */

#line 139 "test.ceu"
    {/* NODE: SetExp 956 */

#line 139 "test.ceu"
/* SET: . */
#line 139 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (y()-30);
#line 139 "test.ceu"
    }
#line 139 "test.ceu"
/* CLEAR: Block (139) */
#line 139 "test.ceu"
    }
#line 139 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_458 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 458 */
/* NODE: Block 457 */

#line 145 "test.ceu"
    {/* NODE: Stmts 456 */

#line 145 "test.ceu"
    {/* NODE: SetExp 957 */

#line 145 "test.ceu"
/* SET: . */
#line 145 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 0;/* NODE: SetExp 958 */

#line 146 "test.ceu"
/* SET: . */
#line 146 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 1;/* NODE: SetExp 959 */

#line 147 "test.ceu"
/* SET: . */
#line 147 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 31;
#line 145 "test.ceu"
    }
#line 145 "test.ceu"
/* CLEAR: Block (145) */
#line 145 "test.ceu"
    }
#line 145 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_484 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 484 */
/* NODE: Block 483 */

#line 155 "test.ceu"
    {/* NODE: Stmts 482 */

#line 155 "test.ceu"
    {/* NODE: SetExp 960 */

#line 155 "test.ceu"
/* SET: . */
#line 155 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 0;/* NODE: SetExp 961 */

#line 156 "test.ceu"
/* SET: . */
#line 156 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 1;/* NODE: SetExp 962 */

#line 157 "test.ceu"
/* SET: . */
#line 157 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 30;
#line 155 "test.ceu"
    }
#line 155 "test.ceu"
/* CLEAR: Block (155) */
#line 155 "test.ceu"
    }
#line 155 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_528 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 528 */
/* NODE: Block 527 */

#line 176 "test.ceu"
    {/* NODE: Stmts 526 */

#line 176 "test.ceu"
    {/* NODE: SetExp 970 */

#line 176 "test.ceu"
/* SET: . */
#line 176 "test.ceu"
    ((CEU_MoveY*)__ceu_org)->distance = (30-y());
#line 176 "test.ceu"
    }
#line 176 "test.ceu"
/* CLEAR: Block (176) */
#line 176 "test.ceu"
    }
#line 176 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_551 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 551 */
/* NODE: Block 550 */

#line 182 "test.ceu"
    {/* NODE: Stmts 549 */

#line 182 "test.ceu"
    {/* NODE: SetExp 971 */

#line 182 "test.ceu"
/* SET: . */
#line 182 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 0;/* NODE: SetExp 972 */

#line 183 "test.ceu"
/* SET: . */
#line 183 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 1;/* NODE: SetExp 973 */

#line 184 "test.ceu"
/* SET: . */
#line 184 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 30;
#line 182 "test.ceu"
    }
#line 182 "test.ceu"
/* CLEAR: Block (182) */
#line 182 "test.ceu"
    }
#line 182 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_577 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 577 */
/* NODE: Block 576 */

#line 192 "test.ceu"
    {/* NODE: Stmts 575 */

#line 192 "test.ceu"
    {/* NODE: SetExp 974 */

#line 192 "test.ceu"
/* SET: . */
#line 192 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 0;/* NODE: SetExp 975 */

#line 193 "test.ceu"
/* SET: . */
#line 193 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 1;/* NODE: SetExp 976 */

#line 194 "test.ceu"
/* SET: . */
#line 194 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 29;
#line 192 "test.ceu"
    }
#line 192 "test.ceu"
/* CLEAR: Block (192) */
#line 192 "test.ceu"
    }
#line 192 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_621 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 621 */
/* NODE: Block 620 */

#line 214 "test.ceu"
    {/* NODE: Stmts 619 */

#line 214 "test.ceu"
    {/* NODE: SetExp 984 */

#line 214 "test.ceu"
/* SET: . */
#line 214 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (30-x());
#line 214 "test.ceu"
    }
#line 214 "test.ceu"
/* CLEAR: Block (214) */
#line 214 "test.ceu"
    }
#line 214 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_644 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 644 */
/* NODE: Block 643 */

#line 220 "test.ceu"
    {/* NODE: Stmts 642 */

#line 220 "test.ceu"
    {/* NODE: SetExp 985 */

#line 220 "test.ceu"
/* SET: . */
#line 220 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 1;/* NODE: SetExp 986 */

#line 221 "test.ceu"
/* SET: . */
#line 221 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 0;/* NODE: SetExp 987 */

#line 222 "test.ceu"
/* SET: . */
#line 222 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 31;
#line 220 "test.ceu"
    }
#line 220 "test.ceu"
/* CLEAR: Block (220) */
#line 220 "test.ceu"
    }
#line 220 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_670 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 670 */
/* NODE: Block 669 */

#line 230 "test.ceu"
    {/* NODE: Stmts 668 */

#line 230 "test.ceu"
    {/* NODE: SetExp 988 */

#line 230 "test.ceu"
/* SET: . */
#line 230 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 1;/* NODE: SetExp 989 */

#line 231 "test.ceu"
/* SET: . */
#line 231 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 0;/* NODE: SetExp 990 */

#line 232 "test.ceu"
/* SET: . */
#line 232 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 30;
#line 230 "test.ceu"
    }
#line 230 "test.ceu"
/* CLEAR: Block (230) */
#line 230 "test.ceu"
    }
#line 230 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_714 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 714 */
/* NODE: Block 713 */

#line 251 "test.ceu"
    {/* NODE: Stmts 712 */

#line 251 "test.ceu"
    {/* NODE: SetExp 998 */

#line 251 "test.ceu"
/* SET: . */
#line 251 "test.ceu"
    ((CEU_MoveX*)__ceu_org)->distance = (30-x());
#line 251 "test.ceu"
    }
#line 251 "test.ceu"
/* CLEAR: Block (251) */
#line 251 "test.ceu"
    }
#line 251 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}
static void _ceu_constr_739 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 739 */
/* NODE: Block 738 */

#line 257 "test.ceu"
    {/* NODE: Stmts 737 */

#line 257 "test.ceu"
    {/* NODE: SetExp 999 */

#line 257 "test.ceu"
/* SET: . */
#line 257 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = (-1);/* NODE: SetExp 1000 */

#line 258 "test.ceu"
/* SET: . */
#line 258 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 0;/* NODE: SetExp 1001 */

#line 259 "test.ceu"
/* SET: . */
#line 259 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = (-29);
#line 257 "test.ceu"
    }
#line 257 "test.ceu"
/* CLEAR: Block (257) */
#line 257 "test.ceu"
    }
#line 257 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 5 ]; */
}
static void _ceu_constr_765 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 765 */
/* NODE: Block 764 */

#line 267 "test.ceu"
    {/* NODE: Stmts 763 */

#line 267 "test.ceu"
    {/* NODE: SetExp 1002 */

#line 267 "test.ceu"
/* SET: . */
#line 267 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->xcoeff = 1;/* NODE: SetExp 1003 */

#line 268 "test.ceu"
/* SET: . */
#line 268 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->ycoeff = 0;/* NODE: SetExp 1004 */

#line 269 "test.ceu"
/* SET: . */
#line 269 "test.ceu"
    ((CEU_Halfplane*)__ceu_org)->offset = 30;
#line 267 "test.ceu"
    }
#line 267 "test.ceu"
/* CLEAR: Block (267) */
#line 267 "test.ceu"
    }
#line 267 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS
static tceu_evtp ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, tceu_evtp param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
#ifndef CEU_OS
            fprintf(stderr, "invalid call %d\n", evt);
#endif
#endif
    }
    return CEU_EVTP((void*)NULL);
}
#endif

static int ceu_app_go (tceu_app* _ceu_app, tceu_go* _ceu_go)
{
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_go->org;
#endif
    _ceu_app->lst.trl = _ceu_go->trl;
    _ceu_app->lst.lbl = _ceu_go->lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_go->org, _ceu_go->lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_go->lbl) {
        /* NODE: Root 1053 */
/* NODE: Dcl_cls 0 */

#line 21 "test.ceu"
case Class_MoveX:;
#line 21 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 0;
#endif
/* NODE: Block 898 */

#line 21 "test.ceu"
    {/* NODE: Stmts 897 */

#line 21 "test.ceu"
    {/* NODE: Block 209 */

#line 25 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 1 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 1 ].lbl   = MoveX_Block__fin_2;
_ceu_go->org->trls[ 1 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 25 "test.ceu"
    ((CEU_MoveX*)_ceu_go->org)->__fin_209_1 = 0;
#line 25 "test.ceu"
    {/* NODE: Stmts 208 */

#line 25 "test.ceu"
    {/* NODE: Stmts 892 */

#line 25 "test.ceu"
    {/* NODE: Dcl_var 889 */
/* NODE: SetExp 893 */

#line 25 "test.ceu"
/* SET: cancel */
#line 25 "test.ceu"
    ((CEU_MoveX*)_ceu_go->org)->cancel = 1;
#line 25 "test.ceu"
    }/* NODE: Finalize 196 */

#line 26 "test.ceu"
    ((CEU_MoveX*)_ceu_go->org)->__fin_209_1 = 1;/* NODE: CallStmt 197 */

#line 32 "test.ceu"
    printf("move x %d starting\n",((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: CallStmt 198 */

#line 33 "test.ceu"
    move_x(((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: AwaitExt 200 */

#line 34 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_X_DONE;
    _ceu_go->trl->lbl = MoveX_Awake_X_DONE_0;

#line 34 "test.ceu"
    	return RET_HALT;
#line 34 "test.ceu"
    case MoveX_Awake_X_DONE_0:;

#line 34 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 201 */

#line 35 "test.ceu"
    printf("move x %d done\n",((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: SetExp 896 */

#line 36 "test.ceu"
/* SET: cancel */
#line 36 "test.ceu"
    ((CEU_MoveX*)_ceu_go->org)->cancel = 0;/* NODE: EmitInt 207 */

#line 37 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = MoveX_EmitInt_cont_1;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_MoveX*)_ceu_go->org);
#endif

#line 37 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case MoveX_EmitInt_cont_1:;

#line 25 "test.ceu"
    }
#line 25 "test.ceu"
    _ceu_go->lbl = MoveX_Block_fin_cnt_3;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 25 "test.ceu"
case MoveX_Block__fin_2:;
#line 25 "test.ceu"
    if (((CEU_MoveX*)_ceu_go->org)->__fin_209_1) {
/* NODE: Finally 195 */
/* NODE: Block 194 */

#line 27 "test.ceu"
    {/* NODE: Stmts 193 */

#line 27 "test.ceu"
    {/* NODE: If 895 */

#line 27 "test.ceu"
    if (((CEU_MoveX*)_ceu_go->org)->cancel) {
/* NODE: Block 191 */

#line 28 "test.ceu"
    {/* NODE: Stmts 190 */

#line 28 "test.ceu"
    {/* NODE: CallStmt 188 */

#line 28 "test.ceu"
    printf("move x %d canceled\n",((CEU_MoveX*)_ceu_go->org)->distance);/* NODE: CallStmt 189 */

#line 29 "test.ceu"
    cancel_x();
#line 28 "test.ceu"
    }
#line 28 "test.ceu"
/* CLEAR: Block (28) */
#line 28 "test.ceu"
    }
#line 28 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Nothing 894 */
}

#line 27 "test.ceu"
    }
#line 27 "test.ceu"
/* CLEAR: Block (27) */
#line 27 "test.ceu"
    }
#line 27 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}

#line 25 "test.ceu"
    	return RET_HALT;
#line 25 "test.ceu"
case MoveX_Block_fin_cnt_3:;
#line 25 "test.ceu"
/* CLEAR: Block (25) */
#line 25 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = MoveX_Clear_4;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 2 ]);

case MoveX_Clear_4:;

#line 25 "test.ceu"
    }
#line 25 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 21 "test.ceu"
    }
#line 21 "test.ceu"
/* CLEAR: Block (21) */
#line 21 "test.ceu"
    }
#line 21 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 21 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 21 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 1 */

#line 40 "test.ceu"
case Class_MoveY:;
#line 40 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 1;
#endif
/* NODE: Block 913 */

#line 40 "test.ceu"
    {/* NODE: Stmts 912 */

#line 40 "test.ceu"
    {/* NODE: Block 240 */

#line 44 "test.ceu"
    /*  FINALIZE */
_ceu_go->org->trls[ 1 ].evt   = CEU_IN__CLEAR;
_ceu_go->org->trls[ 1 ].lbl   = MoveY_Block__fin_9;
_ceu_go->org->trls[ 1 ].seqno = _ceu_app->seqno-1; /* awake now */

#line 44 "test.ceu"
    ((CEU_MoveY*)_ceu_go->org)->__fin_240_1 = 0;
#line 44 "test.ceu"
    {/* NODE: Stmts 239 */

#line 44 "test.ceu"
    {/* NODE: Stmts 907 */

#line 44 "test.ceu"
    {/* NODE: Dcl_var 904 */
/* NODE: SetExp 908 */

#line 44 "test.ceu"
/* SET: cancel */
#line 44 "test.ceu"
    ((CEU_MoveY*)_ceu_go->org)->cancel = 1;
#line 44 "test.ceu"
    }/* NODE: Finalize 227 */

#line 45 "test.ceu"
    ((CEU_MoveY*)_ceu_go->org)->__fin_240_1 = 1;/* NODE: CallStmt 228 */

#line 51 "test.ceu"
    printf("move y %d starting\n",((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: CallStmt 229 */

#line 52 "test.ceu"
    move_y(((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: AwaitExt 231 */

#line 53 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_Y_DONE;
    _ceu_go->trl->lbl = MoveY_Awake_Y_DONE_7;

#line 53 "test.ceu"
    	return RET_HALT;
#line 53 "test.ceu"
    case MoveY_Awake_Y_DONE_7:;

#line 53 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 232 */

#line 54 "test.ceu"
    printf("move y %d done\n",((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: SetExp 911 */

#line 55 "test.ceu"
/* SET: cancel */
#line 55 "test.ceu"
    ((CEU_MoveY*)_ceu_go->org)->cancel = 0;/* NODE: EmitInt 238 */

#line 56 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = MoveY_EmitInt_cont_8;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_MoveY*)_ceu_go->org);
#endif

#line 56 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case MoveY_EmitInt_cont_8:;

#line 44 "test.ceu"
    }
#line 44 "test.ceu"
    _ceu_go->lbl = MoveY_Block_fin_cnt_10;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 44 "test.ceu"
case MoveY_Block__fin_9:;
#line 44 "test.ceu"
    if (((CEU_MoveY*)_ceu_go->org)->__fin_240_1) {
/* NODE: Finally 226 */
/* NODE: Block 225 */

#line 46 "test.ceu"
    {/* NODE: Stmts 224 */

#line 46 "test.ceu"
    {/* NODE: If 910 */

#line 46 "test.ceu"
    if (((CEU_MoveY*)_ceu_go->org)->cancel) {
/* NODE: Block 222 */

#line 47 "test.ceu"
    {/* NODE: Stmts 221 */

#line 47 "test.ceu"
    {/* NODE: CallStmt 219 */

#line 47 "test.ceu"
    printf("move y %d canceled\n",((CEU_MoveY*)_ceu_go->org)->distance);/* NODE: CallStmt 220 */

#line 48 "test.ceu"
    cancel_y();
#line 47 "test.ceu"
    }
#line 47 "test.ceu"
/* CLEAR: Block (47) */
#line 47 "test.ceu"
    }
#line 47 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Nothing 909 */
}

#line 46 "test.ceu"
    }
#line 46 "test.ceu"
/* CLEAR: Block (46) */
#line 46 "test.ceu"
    }
#line 46 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}

#line 44 "test.ceu"
    	return RET_HALT;
#line 44 "test.ceu"
case MoveY_Block_fin_cnt_10:;
#line 44 "test.ceu"
/* CLEAR: Block (44) */
#line 44 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = MoveY_Clear_11;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 2 ]);

case MoveY_Clear_11:;

#line 44 "test.ceu"
    }
#line 44 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 40 "test.ceu"
    }
#line 40 "test.ceu"
/* CLEAR: Block (40) */
#line 40 "test.ceu"
    }
#line 40 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 40 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 40 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 2 */

#line 59 "test.ceu"
case Class_BoxTest:;
#line 59 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 2;
#endif
/* NODE: Block 922 */

#line 59 "test.ceu"
    {/* NODE: Stmts 921 */

#line 59 "test.ceu"
    {/* NODE: Block 300 */

#line 62 "test.ceu"
    {
#line 62 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_300_1);

#line 62 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 2, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_300_2);

#line 62 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 3, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_300_3);

#line 62 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_BoxTest*)_ceu_go->org)->__lnks_300_4);

#line 62 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 299 */

#line 62 "test.ceu"
    {/* NODE: CallStmt 244 */

#line 62 "test.ceu"
    printf("boxtest starting\n");/* NODE: Dcl_var 253 */

#line 63 "test.ceu"
/* start org: right */
#line 63 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 63 "test.ceu"
            _ceu_constr_252(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)), _ceu_go);

#line 63 "test.ceu"
        }
}

#line 63 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_14,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->right)),Class_MoveX);
case BoxTest_Start_cnt_14:;
/* NODE: AwaitInt 256 */

#line 66 "test.ceu"
    _CEU_NO_256_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_15;

#line 66 "test.ceu"
    	return RET_HALT;
#line 66 "test.ceu"
    case BoxTest_Awake_ok_15:;

#line 66 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->right) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_256_;
    }
#endif

#line 66 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 265 */

#line 67 "test.ceu"
/* start org: down */
#line 67 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 67 "test.ceu"
            _ceu_constr_264(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)), _ceu_go);

#line 67 "test.ceu"
        }
}

#line 67 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_16,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->down)),Class_MoveY);
case BoxTest_Start_cnt_16:;
/* NODE: AwaitInt 268 */

#line 70 "test.ceu"
    _CEU_NO_268_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_17;

#line 70 "test.ceu"
    	return RET_HALT;
#line 70 "test.ceu"
    case BoxTest_Awake_ok_17:;

#line 70 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->down) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_268_;
    }
#endif

#line 70 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 278 */

#line 71 "test.ceu"
/* start org: left */
#line 71 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 3);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 71 "test.ceu"
            _ceu_constr_277(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)), _ceu_go);

#line 71 "test.ceu"
        }
}

#line 71 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_18,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->left)),Class_MoveX);
case BoxTest_Start_cnt_18:;
/* NODE: AwaitInt 281 */

#line 74 "test.ceu"
    _CEU_NO_281_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_19;

#line 74 "test.ceu"
    	return RET_HALT;
#line 74 "test.ceu"
    case BoxTest_Awake_ok_19:;

#line 74 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->left) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_281_;
    }
#endif

#line 74 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Dcl_var 291 */

#line 75 "test.ceu"
/* start org: up */
#line 75 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 75 "test.ceu"
            _ceu_constr_290(_ceu_app, ((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)), _ceu_go);

#line 75 "test.ceu"
        }
}

#line 75 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, BoxTest_Start_cnt_20,((tceu_org*) (&((CEU_BoxTest*)_ceu_go->org)->up)),Class_MoveY);
case BoxTest_Start_cnt_20:;
/* NODE: AwaitInt 294 */

#line 78 "test.ceu"
    _CEU_NO_294_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = BoxTest_Awake_ok_21;

#line 78 "test.ceu"
    	return RET_HALT;
#line 78 "test.ceu"
    case BoxTest_Awake_ok_21:;

#line 78 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_BoxTest*)_ceu_go->org)->up) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_294_;
    }
#endif

#line 78 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 295 */

#line 79 "test.ceu"
    printf("boxtest done\n");/* NODE: EmitInt 298 */

#line 80 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = BoxTest_EmitInt_cont_22;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_BoxTest*)_ceu_go->org);
#endif

#line 80 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case BoxTest_EmitInt_cont_22:;

#line 62 "test.ceu"
    }
#line 62 "test.ceu"
/* CLEAR: Block (62) */
#line 62 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = BoxTest_Clear_23;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case BoxTest_Clear_23:;

#line 62 "test.ceu"
    }
#line 62 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 59 "test.ceu"
    }
#line 59 "test.ceu"
/* CLEAR: Block (59) */
#line 59 "test.ceu"
    }
#line 59 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 59 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 59 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 3 */

#line 83 "test.ceu"
case Class_DiagonalTest:;
#line 83 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 3;
#endif
/* NODE: Block 931 */

#line 83 "test.ceu"
    {/* NODE: Stmts 930 */

#line 83 "test.ceu"
    {/* NODE: Block 370 */

#line 86 "test.ceu"
    {/* NODE: Stmts 369 */

#line 86 "test.ceu"
    {/* NODE: CallStmt 304 */

#line 86 "test.ceu"
    printf("diagonaltest starting\n");/* NODE: ParAnd 333 */

#line 87 "test.ceu"
/* close ParAnd gates */
#line 87 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_333_1 = 0;
#line 87 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_333_2 = 0;
#line 87 "test.ceu"
/* ParAnd: spawn subs */
#line 87 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = DiagonalTest_ParAnd_sub_2_26;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 318 */

#line 88 "test.ceu"
    {
#line 88 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_318_1);

#line 88 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 317 */

#line 88 "test.ceu"
    {/* NODE: Dcl_var 313 */

#line 88 "test.ceu"
/* start org: right */
#line 88 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 88 "test.ceu"
            _ceu_constr_312(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)), _ceu_go);

#line 88 "test.ceu"
        }
}

#line 88 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_29,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->right_2)),Class_MoveX);
case DiagonalTest_Start_cnt_29:;
/* NODE: AwaitInt 316 */

#line 91 "test.ceu"
    _CEU_NO_316_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_30;

#line 91 "test.ceu"
    	return RET_HALT;
#line 91 "test.ceu"
    case DiagonalTest_Awake_ok_30:;

#line 91 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->right_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_316_;
    }
#endif

#line 91 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 88 "test.ceu"
    }
#line 88 "test.ceu"
/* CLEAR: Block (88) */
#line 88 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_31;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case DiagonalTest_Clear_31:;

#line 88 "test.ceu"
    }
#line 88 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 87 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_333_1 = 1;
#line 87 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_27;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 87 "test.ceu"
case DiagonalTest_ParAnd_sub_2_26:;/* NODE: Block 332 */

#line 93 "test.ceu"
    {
#line 93 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_332_4);

#line 93 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 331 */

#line 93 "test.ceu"
    {/* NODE: Dcl_var 327 */

#line 93 "test.ceu"
/* start org: down */
#line 93 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 93 "test.ceu"
            _ceu_constr_326(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)), _ceu_go);

#line 93 "test.ceu"
        }
}

#line 93 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_32,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->down_3)),Class_MoveY);
case DiagonalTest_Start_cnt_32:;
/* NODE: AwaitInt 330 */

#line 96 "test.ceu"
    _CEU_NO_330_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_33;

#line 96 "test.ceu"
    	return RET_HALT;
#line 96 "test.ceu"
    case DiagonalTest_Awake_ok_33:;

#line 96 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->down_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_330_;
    }
#endif

#line 96 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 93 "test.ceu"
    }
#line 93 "test.ceu"
/* CLEAR: Block (93) */
#line 93 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_34;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case DiagonalTest_Clear_34:;

#line 93 "test.ceu"
    }
#line 93 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 87 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_333_2 = 1;
#line 87 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_27;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 87 "test.ceu"
case DiagonalTest_ParAnd_chk_27:;
#line 87 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_333_1) {
#line 87 "test.ceu"
    	return RET_HALT;
#line 87 "test.ceu"
    }
#line 87 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_333_2) {
#line 87 "test.ceu"
    	return RET_HALT;
#line 87 "test.ceu"
    }
#line 87 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: ParAnd 364 */

#line 98 "test.ceu"
/* close ParAnd gates */
#line 98 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_364_1 = 0;
#line 98 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_364_2 = 0;
#line 98 "test.ceu"
/* ParAnd: spawn subs */
#line 98 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = DiagonalTest_ParAnd_sub_2_35;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 348 */

#line 99 "test.ceu"
    {
#line 99 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_348_1);

#line 99 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 347 */

#line 99 "test.ceu"
    {/* NODE: Dcl_var 343 */

#line 99 "test.ceu"
/* start org: left */
#line 99 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 99 "test.ceu"
            _ceu_constr_342(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)), _ceu_go);

#line 99 "test.ceu"
        }
}

#line 99 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_38,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->left_4)),Class_MoveX);
case DiagonalTest_Start_cnt_38:;
/* NODE: AwaitInt 346 */

#line 102 "test.ceu"
    _CEU_NO_346_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_39;

#line 102 "test.ceu"
    	return RET_HALT;
#line 102 "test.ceu"
    case DiagonalTest_Awake_ok_39:;

#line 102 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->left_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_346_;
    }
#endif

#line 102 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 99 "test.ceu"
    }
#line 99 "test.ceu"
/* CLEAR: Block (99) */
#line 99 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_40;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case DiagonalTest_Clear_40:;

#line 99 "test.ceu"
    }
#line 99 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 98 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_364_1 = 1;
#line 98 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_36;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 98 "test.ceu"
case DiagonalTest_ParAnd_sub_2_35:;/* NODE: Block 363 */

#line 104 "test.ceu"
    {
#line 104 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_DiagonalTest*)_ceu_go->org)->__lnks_363_4);

#line 104 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 362 */

#line 104 "test.ceu"
    {/* NODE: Dcl_var 358 */

#line 104 "test.ceu"
/* start org: up */
#line 104 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 104 "test.ceu"
            _ceu_constr_357(_ceu_app, ((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)), _ceu_go);

#line 104 "test.ceu"
        }
}

#line 104 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, DiagonalTest_Start_cnt_41,((tceu_org*) (&((CEU_DiagonalTest*)_ceu_go->org)->up_5)),Class_MoveY);
case DiagonalTest_Start_cnt_41:;
/* NODE: AwaitInt 361 */

#line 107 "test.ceu"
    _CEU_NO_361_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = DiagonalTest_Awake_ok_42;

#line 107 "test.ceu"
    	return RET_HALT;
#line 107 "test.ceu"
    case DiagonalTest_Awake_ok_42:;

#line 107 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_DiagonalTest*)_ceu_go->org)->up_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_361_;
    }
#endif

#line 107 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 104 "test.ceu"
    }
#line 104 "test.ceu"
/* CLEAR: Block (104) */
#line 104 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = DiagonalTest_Clear_43;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case DiagonalTest_Clear_43:;

#line 104 "test.ceu"
    }
#line 104 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 98 "test.ceu"
    ((CEU_DiagonalTest*)_ceu_go->org)->__and_364_2 = 1;
#line 98 "test.ceu"
    _ceu_go->lbl = DiagonalTest_ParAnd_chk_36;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 98 "test.ceu"
case DiagonalTest_ParAnd_chk_36:;
#line 98 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_364_1) {
#line 98 "test.ceu"
    	return RET_HALT;
#line 98 "test.ceu"
    }
#line 98 "test.ceu"
    if (!((CEU_DiagonalTest*)_ceu_go->org)->__and_364_2) {
#line 98 "test.ceu"
    	return RET_HALT;
#line 98 "test.ceu"
    }
#line 98 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: CallStmt 365 */

#line 109 "test.ceu"
    printf("diagonaltest done\n");/* NODE: EmitInt 368 */

#line 110 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = DiagonalTest_EmitInt_cont_44;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_DiagonalTest*)_ceu_go->org);
#endif

#line 110 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case DiagonalTest_EmitInt_cont_44:;

#line 86 "test.ceu"
    }
#line 86 "test.ceu"
/* CLEAR: Block (86) */
#line 86 "test.ceu"
    }
#line 86 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 83 "test.ceu"
    }
#line 83 "test.ceu"
/* CLEAR: Block (83) */
#line 83 "test.ceu"
    }
#line 83 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 83 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 83 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 4 */

#line 113 "test.ceu"
case Class_Halfplane:;
#line 113 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 4;
#endif
/* NODE: Block 947 */

#line 113 "test.ceu"
    {/* NODE: Stmts 946 */

#line 113 "test.ceu"
    {/* NODE: Block 406 */

#line 119 "test.ceu"
    {/* NODE: Stmts 405 */

#line 119 "test.ceu"
    {/* NODE: Loop 943 */

#line 119 "test.ceu"
    for (;;) {
/* NODE: Stmts 942 */

#line 119 "test.ceu"
    {/* NODE: AwaitExt 941 */

#line 119 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_TICK;
    _ceu_go->trl->lbl = Halfplane_Awake_TICK_47;

#line 119 "test.ceu"
    	return RET_HALT;
#line 119 "test.ceu"
    case Halfplane_Awake_TICK_47:;

#line 119 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 403 */

#line 120 "test.ceu"
    {/* NODE: Stmts 402 */

#line 120 "test.ceu"
    {/* NODE: If 945 */

#line 120 "test.ceu"
    if ((((x()*((CEU_Halfplane*)_ceu_go->org)->xcoeff)+(y()*((CEU_Halfplane*)_ceu_go->org)->ycoeff))<((CEU_Halfplane*)_ceu_go->org)->offset)) {
/* NODE: Block 400 */

#line 121 "test.ceu"
    {/* NODE: Stmts 399 */

#line 121 "test.ceu"
    {/* NODE: EmitInt 398 */

#line 121 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Halfplane_EmitInt_cont_48;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Halfplane*)_ceu_go->org);
#endif

#line 121 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Halfplane_EmitInt_cont_48:;

#line 121 "test.ceu"
    }
#line 121 "test.ceu"
/* CLEAR: Block (121) */
#line 121 "test.ceu"
    }
#line 121 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Nothing 944 */
}

#line 120 "test.ceu"
    }
#line 120 "test.ceu"
/* CLEAR: Block (120) */
#line 120 "test.ceu"
    }
#line 120 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 119 "test.ceu"
    }
#line 119 "test.ceu"
    }

#line 119 "test.ceu"
    }
#line 119 "test.ceu"
/* CLEAR: Block (119) */
#line 119 "test.ceu"
    }
#line 113 "test.ceu"
    }
#line 113 "test.ceu"
/* CLEAR: Block (113) */
#line 113 "test.ceu"
    }/* NODE: Dcl_cls 5 */

#line 126 "test.ceu"
case Class_Skip:;
#line 126 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 5;
#endif
/* NODE: Block 952 */

#line 126 "test.ceu"
    {/* NODE: Stmts 951 */

#line 126 "test.ceu"
    {/* NODE: Block 414 */

#line 129 "test.ceu"
    {/* NODE: Stmts 413 */

#line 129 "test.ceu"
    {/* NODE: EmitInt 412 */

#line 129 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Skip_EmitInt_cont_51;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Skip*)_ceu_go->org);
#endif

#line 129 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Skip_EmitInt_cont_51:;

#line 129 "test.ceu"
    }
#line 129 "test.ceu"
/* CLEAR: Block (129) */
#line 129 "test.ceu"
    }
#line 129 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 126 "test.ceu"
    }
#line 126 "test.ceu"
/* CLEAR: Block (126) */
#line 126 "test.ceu"
    }
#line 126 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 126 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 126 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 6 */

#line 132 "test.ceu"
case Class_Quux:;
#line 132 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 6;
#endif
/* NODE: Block 966 */

#line 132 "test.ceu"
    {/* NODE: Stmts 965 */

#line 132 "test.ceu"
    {/* NODE: Block 507 */

#line 135 "test.ceu"
    {/* NODE: Stmts 506 */

#line 135 "test.ceu"
    {/* NODE: If 502 */

#line 135 "test.ceu"
    if ((y()>30)) {
/* NODE: Block 468 */

#line 136 "test.ceu"
    {/* NODE: Stmts 467 */

#line 136 "test.ceu"
    {/* NODE: ParOr 466 */

#line 136 "test.ceu"
/* ParOr: spawn subs */
#line 136 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Quux_ParOr_sub_2_54;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 442 */

#line 137 "test.ceu"
    {
#line 137 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Quux*)_ceu_go->org)->__lnks_442_1);

#line 137 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 441 */

#line 137 "test.ceu"
    {/* NODE: CallStmt 423 */

#line 137 "test.ceu"
    printf("Quux starting up\n");/* NODE: Dcl_var 436 */

#line 138 "test.ceu"
/* start org: up */
#line 138 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->up_2)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 138 "test.ceu"
            _ceu_constr_435(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->up_2)), _ceu_go);

#line 138 "test.ceu"
        }
}

#line 138 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Quux_Start_cnt_56,((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->up_2)),Class_MoveY);
case Quux_Start_cnt_56:;
/* NODE: AwaitInt 439 */

#line 141 "test.ceu"
    _CEU_NO_439_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Quux_Awake_ok_57;

#line 141 "test.ceu"
    	return RET_HALT;
#line 141 "test.ceu"
    case Quux_Awake_ok_57:;

#line 141 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Quux*)_ceu_go->org)->up_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_439_;
    }
#endif

#line 141 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 440 */

#line 142 "test.ceu"
    printf("Quux done up\n");
#line 137 "test.ceu"
    }
#line 137 "test.ceu"
/* CLEAR: Block (137) */
#line 137 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_58;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Quux_Clear_58:;

#line 137 "test.ceu"
    }
#line 137 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 136 "test.ceu"
/* PAROR JOIN */
#line 136 "test.ceu"
    _ceu_go->lbl = Quux_ParOr_out_55;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 136 "test.ceu"
case Quux_ParOr_sub_2_54:;/* NODE: Block 465 */

#line 144 "test.ceu"
    {
#line 144 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Quux*)_ceu_go->org)->__lnks_465_4);

#line 144 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 464 */

#line 144 "test.ceu"
    {/* NODE: Dcl_var 459 */

#line 144 "test.ceu"
/* start org: guard */
#line 144 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_3)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 144 "test.ceu"
            _ceu_constr_458(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_3)), _ceu_go);

#line 144 "test.ceu"
        }
}

#line 144 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Quux_Start_cnt_59,((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_3)),Class_Halfplane);
case Quux_Start_cnt_59:;
/* NODE: AwaitInt 462 */

#line 149 "test.ceu"
    _CEU_NO_462_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Quux_Awake_ok_60;

#line 149 "test.ceu"
    	return RET_HALT;
#line 149 "test.ceu"
    case Quux_Awake_ok_60:;

#line 149 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Quux*)_ceu_go->org)->guard_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_462_;
    }
#endif

#line 149 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 463 */

#line 150 "test.ceu"
    printf("Quux up disqualified\n");
#line 144 "test.ceu"
    }
#line 144 "test.ceu"
/* CLEAR: Block (144) */
#line 144 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_61;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Quux_Clear_61:;

#line 144 "test.ceu"
    }
#line 144 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 136 "test.ceu"
/* PAROR JOIN */
#line 136 "test.ceu"
    _ceu_go->lbl = Quux_ParOr_out_55;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 136 "test.ceu"
case Quux_ParOr_out_55:;
#line 136 "test.ceu"
/* CLEAR: ParOr (136) */
#line 136 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_62;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Quux_Clear_62:;

#line 136 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 136 "test.ceu"
    }
#line 136 "test.ceu"
/* CLEAR: Block (136) */
#line 136 "test.ceu"
    }
#line 136 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 501 */

#line 153 "test.ceu"
    {/* NODE: Stmts 500 */

#line 153 "test.ceu"
    {/* NODE: ParOr 499 */

#line 153 "test.ceu"
/* ParOr: spawn subs */
#line 153 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Quux_ParOr_sub_2_63;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 491 */

#line 154 "test.ceu"
    {
#line 154 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Quux*)_ceu_go->org)->__lnks_491_1);

#line 154 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 490 */

#line 154 "test.ceu"
    {/* NODE: Dcl_var 485 */

#line 154 "test.ceu"
/* start org: guard */
#line 154 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_4)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 154 "test.ceu"
            _ceu_constr_484(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_4)), _ceu_go);

#line 154 "test.ceu"
        }
}

#line 154 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Quux_Start_cnt_65,((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->guard_4)),Class_Halfplane);
case Quux_Start_cnt_65:;
/* NODE: AwaitInt 488 */

#line 159 "test.ceu"
    _CEU_NO_488_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Quux_Awake_ok_66;

#line 159 "test.ceu"
    	return RET_HALT;
#line 159 "test.ceu"
    case Quux_Awake_ok_66:;

#line 159 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Quux*)_ceu_go->org)->guard_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_488_;
    }
#endif

#line 159 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 489 */

#line 160 "test.ceu"
    printf("Quux up preempts\n");
#line 154 "test.ceu"
    }
#line 154 "test.ceu"
/* CLEAR: Block (154) */
#line 154 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_67;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Quux_Clear_67:;

#line 154 "test.ceu"
    }
#line 154 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 153 "test.ceu"
/* PAROR JOIN */
#line 153 "test.ceu"
    _ceu_go->lbl = Quux_ParOr_out_64;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 153 "test.ceu"
case Quux_ParOr_sub_2_63:;/* NODE: Block 498 */

#line 162 "test.ceu"
    {
#line 162 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Quux*)_ceu_go->org)->__lnks_498_4);

#line 162 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 497 */

#line 162 "test.ceu"
    {/* NODE: Stmts 964 */

#line 162 "test.ceu"
    {/* NODE: Dcl_var 963 */

#line 162 "test.ceu"
/* start org: default */
#line 162 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->default_5)),2,Class_Skip,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 162 "test.ceu"
        }
}

#line 162 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Quux_Start_cnt_68,((tceu_org*) (&((CEU_Quux*)_ceu_go->org)->default_5)),Class_Skip);
case Quux_Start_cnt_68:;

#line 162 "test.ceu"
    }/* NODE: AwaitInt 496 */

#line 163 "test.ceu"
    _CEU_NO_496_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Quux_Awake_ok_69;

#line 163 "test.ceu"
    	return RET_HALT;
#line 163 "test.ceu"
    case Quux_Awake_ok_69:;

#line 163 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Quux*)_ceu_go->org)->default_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_496_;
    }
#endif

#line 163 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 162 "test.ceu"
    }
#line 162 "test.ceu"
/* CLEAR: Block (162) */
#line 162 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_70;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Quux_Clear_70:;

#line 162 "test.ceu"
    }
#line 162 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 153 "test.ceu"
/* PAROR JOIN */
#line 153 "test.ceu"
    _ceu_go->lbl = Quux_ParOr_out_64;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 153 "test.ceu"
case Quux_ParOr_out_64:;
#line 153 "test.ceu"
/* CLEAR: ParOr (153) */
#line 153 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Quux_Clear_71;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Quux_Clear_71:;

#line 153 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 153 "test.ceu"
    }
#line 153 "test.ceu"
/* CLEAR: Block (153) */
#line 153 "test.ceu"
    }
#line 153 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}
/* NODE: EmitInt 505 */

#line 166 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Quux_EmitInt_cont_72;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Quux*)_ceu_go->org);
#endif

#line 166 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Quux_EmitInt_cont_72:;

#line 135 "test.ceu"
    }
#line 135 "test.ceu"
/* CLEAR: Block (135) */
#line 135 "test.ceu"
    }
#line 135 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 132 "test.ceu"
    }
#line 132 "test.ceu"
/* CLEAR: Block (132) */
#line 132 "test.ceu"
    }
#line 132 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 132 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 132 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 7 */

#line 169 "test.ceu"
case Class_Qux:;
#line 169 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 7;
#endif
/* NODE: Block 980 */

#line 169 "test.ceu"
    {/* NODE: Stmts 979 */

#line 169 "test.ceu"
    {/* NODE: Block 600 */

#line 172 "test.ceu"
    {/* NODE: Stmts 599 */

#line 172 "test.ceu"
    {/* NODE: If 595 */

#line 172 "test.ceu"
    if ((y()<30)) {
/* NODE: Block 561 */

#line 173 "test.ceu"
    {/* NODE: Stmts 560 */

#line 173 "test.ceu"
    {/* NODE: ParOr 559 */

#line 173 "test.ceu"
/* ParOr: spawn subs */
#line 173 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Qux_ParOr_sub_2_75;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 535 */

#line 174 "test.ceu"
    {
#line 174 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Qux*)_ceu_go->org)->__lnks_535_1);

#line 174 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 534 */

#line 174 "test.ceu"
    {/* NODE: CallStmt 516 */

#line 174 "test.ceu"
    printf("Qux starting down\n");/* NODE: Dcl_var 529 */

#line 175 "test.ceu"
/* start org: move */
#line 175 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->move_2)),3,Class_MoveY,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 175 "test.ceu"
            _ceu_constr_528(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->move_2)), _ceu_go);

#line 175 "test.ceu"
        }
}

#line 175 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Qux_Start_cnt_77,((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->move_2)),Class_MoveY);
case Qux_Start_cnt_77:;
/* NODE: AwaitInt 532 */

#line 178 "test.ceu"
    _CEU_NO_532_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Qux_Awake_ok_78;

#line 178 "test.ceu"
    	return RET_HALT;
#line 178 "test.ceu"
    case Qux_Awake_ok_78:;

#line 178 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Qux*)_ceu_go->org)->move_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_532_;
    }
#endif

#line 178 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 533 */

#line 179 "test.ceu"
    printf("Qux done down\n");
#line 174 "test.ceu"
    }
#line 174 "test.ceu"
/* CLEAR: Block (174) */
#line 174 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_79;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Qux_Clear_79:;

#line 174 "test.ceu"
    }
#line 174 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 173 "test.ceu"
/* PAROR JOIN */
#line 173 "test.ceu"
    _ceu_go->lbl = Qux_ParOr_out_76;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 173 "test.ceu"
case Qux_ParOr_sub_2_75:;/* NODE: Block 558 */

#line 181 "test.ceu"
    {
#line 181 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Qux*)_ceu_go->org)->__lnks_558_4);

#line 181 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 557 */

#line 181 "test.ceu"
    {/* NODE: Dcl_var 552 */

#line 181 "test.ceu"
/* start org: guard */
#line 181 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_3)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 181 "test.ceu"
            _ceu_constr_551(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_3)), _ceu_go);

#line 181 "test.ceu"
        }
}

#line 181 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Qux_Start_cnt_80,((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_3)),Class_Halfplane);
case Qux_Start_cnt_80:;
/* NODE: AwaitInt 555 */

#line 186 "test.ceu"
    _CEU_NO_555_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Qux_Awake_ok_81;

#line 186 "test.ceu"
    	return RET_HALT;
#line 186 "test.ceu"
    case Qux_Awake_ok_81:;

#line 186 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Qux*)_ceu_go->org)->guard_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_555_;
    }
#endif

#line 186 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 556 */

#line 187 "test.ceu"
    printf("Qux down disqualified\n");
#line 181 "test.ceu"
    }
#line 181 "test.ceu"
/* CLEAR: Block (181) */
#line 181 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_82;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Qux_Clear_82:;

#line 181 "test.ceu"
    }
#line 181 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 173 "test.ceu"
/* PAROR JOIN */
#line 173 "test.ceu"
    _ceu_go->lbl = Qux_ParOr_out_76;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 173 "test.ceu"
case Qux_ParOr_out_76:;
#line 173 "test.ceu"
/* CLEAR: ParOr (173) */
#line 173 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_83;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Qux_Clear_83:;

#line 173 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 173 "test.ceu"
    }
#line 173 "test.ceu"
/* CLEAR: Block (173) */
#line 173 "test.ceu"
    }
#line 173 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 594 */

#line 190 "test.ceu"
    {/* NODE: Stmts 593 */

#line 190 "test.ceu"
    {/* NODE: ParOr 592 */

#line 190 "test.ceu"
/* ParOr: spawn subs */
#line 190 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Qux_ParOr_sub_2_84;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 584 */

#line 191 "test.ceu"
    {
#line 191 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Qux*)_ceu_go->org)->__lnks_584_1);

#line 191 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 583 */

#line 191 "test.ceu"
    {/* NODE: Dcl_var 578 */

#line 191 "test.ceu"
/* start org: guard */
#line 191 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_4)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 191 "test.ceu"
            _ceu_constr_577(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_4)), _ceu_go);

#line 191 "test.ceu"
        }
}

#line 191 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Qux_Start_cnt_86,((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->guard_4)),Class_Halfplane);
case Qux_Start_cnt_86:;
/* NODE: AwaitInt 581 */

#line 196 "test.ceu"
    _CEU_NO_581_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Qux_Awake_ok_87;

#line 196 "test.ceu"
    	return RET_HALT;
#line 196 "test.ceu"
    case Qux_Awake_ok_87:;

#line 196 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Qux*)_ceu_go->org)->guard_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_581_;
    }
#endif

#line 196 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 582 */

#line 197 "test.ceu"
    printf("Qux down preempts\n");
#line 191 "test.ceu"
    }
#line 191 "test.ceu"
/* CLEAR: Block (191) */
#line 191 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_88;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Qux_Clear_88:;

#line 191 "test.ceu"
    }
#line 191 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 190 "test.ceu"
/* PAROR JOIN */
#line 190 "test.ceu"
    _ceu_go->lbl = Qux_ParOr_out_85;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 190 "test.ceu"
case Qux_ParOr_sub_2_84:;/* NODE: Block 591 */

#line 199 "test.ceu"
    {
#line 199 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Qux*)_ceu_go->org)->__lnks_591_4);

#line 199 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 590 */

#line 199 "test.ceu"
    {/* NODE: Stmts 978 */

#line 199 "test.ceu"
    {/* NODE: Dcl_var 977 */

#line 199 "test.ceu"
/* start org: default */
#line 199 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->default_5)),7,Class_Quux,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 199 "test.ceu"
        }
}

#line 199 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Qux_Start_cnt_89,((tceu_org*) (&((CEU_Qux*)_ceu_go->org)->default_5)),Class_Quux);
case Qux_Start_cnt_89:;

#line 199 "test.ceu"
    }/* NODE: AwaitInt 589 */

#line 200 "test.ceu"
    _CEU_NO_589_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Qux_Awake_ok_90;

#line 200 "test.ceu"
    	return RET_HALT;
#line 200 "test.ceu"
    case Qux_Awake_ok_90:;

#line 200 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Qux*)_ceu_go->org)->default_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_589_;
    }
#endif

#line 200 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 199 "test.ceu"
    }
#line 199 "test.ceu"
/* CLEAR: Block (199) */
#line 199 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_91;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Qux_Clear_91:;

#line 199 "test.ceu"
    }
#line 199 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 190 "test.ceu"
/* PAROR JOIN */
#line 190 "test.ceu"
    _ceu_go->lbl = Qux_ParOr_out_85;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 190 "test.ceu"
case Qux_ParOr_out_85:;
#line 190 "test.ceu"
/* CLEAR: ParOr (190) */
#line 190 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Qux_Clear_92;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Qux_Clear_92:;

#line 190 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 190 "test.ceu"
    }
#line 190 "test.ceu"
/* CLEAR: Block (190) */
#line 190 "test.ceu"
    }
#line 190 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}
/* NODE: EmitInt 598 */

#line 203 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Qux_EmitInt_cont_93;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Qux*)_ceu_go->org);
#endif

#line 203 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Qux_EmitInt_cont_93:;

#line 172 "test.ceu"
    }
#line 172 "test.ceu"
/* CLEAR: Block (172) */
#line 172 "test.ceu"
    }
#line 172 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 169 "test.ceu"
    }
#line 169 "test.ceu"
/* CLEAR: Block (169) */
#line 169 "test.ceu"
    }
#line 169 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 169 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 169 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 8 */

#line 207 "test.ceu"
case Class_Bar:;
#line 207 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 8;
#endif
/* NODE: Block 994 */

#line 207 "test.ceu"
    {/* NODE: Stmts 993 */

#line 207 "test.ceu"
    {/* NODE: Block 693 */

#line 210 "test.ceu"
    {/* NODE: Stmts 692 */

#line 210 "test.ceu"
    {/* NODE: If 688 */

#line 210 "test.ceu"
    if ((x()>30)) {
/* NODE: Block 654 */

#line 211 "test.ceu"
    {/* NODE: Stmts 653 */

#line 211 "test.ceu"
    {/* NODE: ParOr 652 */

#line 211 "test.ceu"
/* ParOr: spawn subs */
#line 211 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Bar_ParOr_sub_2_96;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 628 */

#line 212 "test.ceu"
    {
#line 212 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Bar*)_ceu_go->org)->__lnks_628_1);

#line 212 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 627 */

#line 212 "test.ceu"
    {/* NODE: CallStmt 609 */

#line 212 "test.ceu"
    printf("Bar starting left\n");/* NODE: Dcl_var 622 */

#line 213 "test.ceu"
/* start org: move */
#line 213 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->move_2)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 213 "test.ceu"
            _ceu_constr_621(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->move_2)), _ceu_go);

#line 213 "test.ceu"
        }
}

#line 213 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Bar_Start_cnt_98,((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->move_2)),Class_MoveX);
case Bar_Start_cnt_98:;
/* NODE: AwaitInt 625 */

#line 216 "test.ceu"
    _CEU_NO_625_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Bar_Awake_ok_99;

#line 216 "test.ceu"
    	return RET_HALT;
#line 216 "test.ceu"
    case Bar_Awake_ok_99:;

#line 216 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Bar*)_ceu_go->org)->move_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_625_;
    }
#endif

#line 216 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 626 */

#line 217 "test.ceu"
    printf("Bar done left\n");
#line 212 "test.ceu"
    }
#line 212 "test.ceu"
/* CLEAR: Block (212) */
#line 212 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_100;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Bar_Clear_100:;

#line 212 "test.ceu"
    }
#line 212 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 211 "test.ceu"
/* PAROR JOIN */
#line 211 "test.ceu"
    _ceu_go->lbl = Bar_ParOr_out_97;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 211 "test.ceu"
case Bar_ParOr_sub_2_96:;/* NODE: Block 651 */

#line 219 "test.ceu"
    {
#line 219 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Bar*)_ceu_go->org)->__lnks_651_4);

#line 219 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 650 */

#line 219 "test.ceu"
    {/* NODE: Dcl_var 645 */

#line 219 "test.ceu"
/* start org: guard */
#line 219 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_3)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 219 "test.ceu"
            _ceu_constr_644(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_3)), _ceu_go);

#line 219 "test.ceu"
        }
}

#line 219 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Bar_Start_cnt_101,((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_3)),Class_Halfplane);
case Bar_Start_cnt_101:;
/* NODE: AwaitInt 648 */

#line 224 "test.ceu"
    _CEU_NO_648_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Bar_Awake_ok_102;

#line 224 "test.ceu"
    	return RET_HALT;
#line 224 "test.ceu"
    case Bar_Awake_ok_102:;

#line 224 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Bar*)_ceu_go->org)->guard_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_648_;
    }
#endif

#line 224 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 649 */

#line 225 "test.ceu"
    printf("Bar left disqualified\n");
#line 219 "test.ceu"
    }
#line 219 "test.ceu"
/* CLEAR: Block (219) */
#line 219 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_103;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Bar_Clear_103:;

#line 219 "test.ceu"
    }
#line 219 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 211 "test.ceu"
/* PAROR JOIN */
#line 211 "test.ceu"
    _ceu_go->lbl = Bar_ParOr_out_97;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 211 "test.ceu"
case Bar_ParOr_out_97:;
#line 211 "test.ceu"
/* CLEAR: ParOr (211) */
#line 211 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_104;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Bar_Clear_104:;

#line 211 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 211 "test.ceu"
    }
#line 211 "test.ceu"
/* CLEAR: Block (211) */
#line 211 "test.ceu"
    }
#line 211 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 687 */

#line 228 "test.ceu"
    {/* NODE: Stmts 686 */

#line 228 "test.ceu"
    {/* NODE: ParOr 685 */

#line 228 "test.ceu"
/* ParOr: spawn subs */
#line 228 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Bar_ParOr_sub_2_105;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 677 */

#line 229 "test.ceu"
    {
#line 229 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Bar*)_ceu_go->org)->__lnks_677_1);

#line 229 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 676 */

#line 229 "test.ceu"
    {/* NODE: Dcl_var 671 */

#line 229 "test.ceu"
/* start org: guard */
#line 229 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_4)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 229 "test.ceu"
            _ceu_constr_670(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_4)), _ceu_go);

#line 229 "test.ceu"
        }
}

#line 229 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Bar_Start_cnt_107,((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->guard_4)),Class_Halfplane);
case Bar_Start_cnt_107:;
/* NODE: AwaitInt 674 */

#line 234 "test.ceu"
    _CEU_NO_674_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Bar_Awake_ok_108;

#line 234 "test.ceu"
    	return RET_HALT;
#line 234 "test.ceu"
    case Bar_Awake_ok_108:;

#line 234 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Bar*)_ceu_go->org)->guard_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_674_;
    }
#endif

#line 234 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 675 */

#line 235 "test.ceu"
    printf("Bar left preempts\n");
#line 229 "test.ceu"
    }
#line 229 "test.ceu"
/* CLEAR: Block (229) */
#line 229 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_109;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Bar_Clear_109:;

#line 229 "test.ceu"
    }
#line 229 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 228 "test.ceu"
/* PAROR JOIN */
#line 228 "test.ceu"
    _ceu_go->lbl = Bar_ParOr_out_106;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 228 "test.ceu"
case Bar_ParOr_sub_2_105:;/* NODE: Block 684 */

#line 237 "test.ceu"
    {
#line 237 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Bar*)_ceu_go->org)->__lnks_684_4);

#line 237 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 683 */

#line 237 "test.ceu"
    {/* NODE: Stmts 992 */

#line 237 "test.ceu"
    {/* NODE: Dcl_var 991 */

#line 237 "test.ceu"
/* start org: default */
#line 237 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->default_5)),7,Class_Qux,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 237 "test.ceu"
        }
}

#line 237 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Bar_Start_cnt_110,((tceu_org*) (&((CEU_Bar*)_ceu_go->org)->default_5)),Class_Qux);
case Bar_Start_cnt_110:;

#line 237 "test.ceu"
    }/* NODE: AwaitInt 682 */

#line 238 "test.ceu"
    _CEU_NO_682_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Bar_Awake_ok_111;

#line 238 "test.ceu"
    	return RET_HALT;
#line 238 "test.ceu"
    case Bar_Awake_ok_111:;

#line 238 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Bar*)_ceu_go->org)->default_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_682_;
    }
#endif

#line 238 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 237 "test.ceu"
    }
#line 237 "test.ceu"
/* CLEAR: Block (237) */
#line 237 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_112;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Bar_Clear_112:;

#line 237 "test.ceu"
    }
#line 237 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 228 "test.ceu"
/* PAROR JOIN */
#line 228 "test.ceu"
    _ceu_go->lbl = Bar_ParOr_out_106;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 228 "test.ceu"
case Bar_ParOr_out_106:;
#line 228 "test.ceu"
/* CLEAR: ParOr (228) */
#line 228 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Bar_Clear_113;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Bar_Clear_113:;

#line 228 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 228 "test.ceu"
    }
#line 228 "test.ceu"
/* CLEAR: Block (228) */
#line 228 "test.ceu"
    }
#line 228 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}
/* NODE: EmitInt 691 */

#line 241 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Bar_EmitInt_cont_114;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Bar*)_ceu_go->org);
#endif

#line 241 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Bar_EmitInt_cont_114:;

#line 210 "test.ceu"
    }
#line 210 "test.ceu"
/* CLEAR: Block (210) */
#line 210 "test.ceu"
    }
#line 210 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 207 "test.ceu"
    }
#line 207 "test.ceu"
/* CLEAR: Block (207) */
#line 207 "test.ceu"
    }
#line 207 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 207 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 207 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 9 */

#line 244 "test.ceu"
case Class_Foo:;
#line 244 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 9;
#endif
/* NODE: Block 1008 */

#line 244 "test.ceu"
    {/* NODE: Stmts 1007 */

#line 244 "test.ceu"
    {/* NODE: Block 788 */

#line 247 "test.ceu"
    {/* NODE: Stmts 787 */

#line 247 "test.ceu"
    {/* NODE: If 783 */

#line 247 "test.ceu"
    if ((x()<30)) {
/* NODE: Block 749 */

#line 248 "test.ceu"
    {/* NODE: Stmts 748 */

#line 248 "test.ceu"
    {/* NODE: ParOr 747 */

#line 248 "test.ceu"
/* ParOr: spawn subs */
#line 248 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Foo_ParOr_sub_2_117;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 721 */

#line 249 "test.ceu"
    {
#line 249 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Foo*)_ceu_go->org)->__lnks_721_1);

#line 249 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 720 */

#line 249 "test.ceu"
    {/* NODE: CallStmt 702 */

#line 249 "test.ceu"
    printf("Foo right starts\n");/* NODE: Dcl_var 715 */

#line 250 "test.ceu"
/* start org: go_right */
#line 250 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->go_right_2)),3,Class_MoveX,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 250 "test.ceu"
            _ceu_constr_714(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->go_right_2)), _ceu_go);

#line 250 "test.ceu"
        }
}

#line 250 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Foo_Start_cnt_119,((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->go_right_2)),Class_MoveX);
case Foo_Start_cnt_119:;
/* NODE: AwaitInt 718 */

#line 253 "test.ceu"
    _CEU_NO_718_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Foo_Awake_ok_120;

#line 253 "test.ceu"
    	return RET_HALT;
#line 253 "test.ceu"
    case Foo_Awake_ok_120:;

#line 253 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Foo*)_ceu_go->org)->go_right_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_718_;
    }
#endif

#line 253 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 719 */

#line 254 "test.ceu"
    printf("Foo right done\n");
#line 249 "test.ceu"
    }
#line 249 "test.ceu"
/* CLEAR: Block (249) */
#line 249 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_121;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Foo_Clear_121:;

#line 249 "test.ceu"
    }
#line 249 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 248 "test.ceu"
/* PAROR JOIN */
#line 248 "test.ceu"
    _ceu_go->lbl = Foo_ParOr_out_118;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 248 "test.ceu"
case Foo_ParOr_sub_2_117:;/* NODE: Block 746 */

#line 256 "test.ceu"
    {
#line 256 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Foo*)_ceu_go->org)->__lnks_746_4);

#line 256 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 745 */

#line 256 "test.ceu"
    {/* NODE: Dcl_var 740 */

#line 256 "test.ceu"
/* start org: guard */
#line 256 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_3)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 256 "test.ceu"
            _ceu_constr_739(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_3)), _ceu_go);

#line 256 "test.ceu"
        }
}

#line 256 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Foo_Start_cnt_122,((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_3)),Class_Halfplane);
case Foo_Start_cnt_122:;
/* NODE: AwaitInt 743 */

#line 261 "test.ceu"
    _CEU_NO_743_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Foo_Awake_ok_123;

#line 261 "test.ceu"
    	return RET_HALT;
#line 261 "test.ceu"
    case Foo_Awake_ok_123:;

#line 261 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Foo*)_ceu_go->org)->guard_3) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_743_;
    }
#endif

#line 261 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 744 */

#line 262 "test.ceu"
    printf("Foo right disqualified\n");
#line 256 "test.ceu"
    }
#line 256 "test.ceu"
/* CLEAR: Block (256) */
#line 256 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_124;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Foo_Clear_124:;

#line 256 "test.ceu"
    }
#line 256 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 248 "test.ceu"
/* PAROR JOIN */
#line 248 "test.ceu"
    _ceu_go->lbl = Foo_ParOr_out_118;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 248 "test.ceu"
case Foo_ParOr_out_118:;
#line 248 "test.ceu"
/* CLEAR: ParOr (248) */
#line 248 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_125;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Foo_Clear_125:;

#line 248 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 248 "test.ceu"
    }
#line 248 "test.ceu"
/* CLEAR: Block (248) */
#line 248 "test.ceu"
    }
#line 248 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 782 */

#line 265 "test.ceu"
    {/* NODE: Stmts 781 */

#line 265 "test.ceu"
    {/* NODE: ParOr 780 */

#line 265 "test.ceu"
/* ParOr: spawn subs */
#line 265 "test.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Foo_ParOr_sub_2_126;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 772 */

#line 266 "test.ceu"
    {
#line 266 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Foo*)_ceu_go->org)->__lnks_772_1);

#line 266 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 771 */

#line 266 "test.ceu"
    {/* NODE: Dcl_var 766 */

#line 266 "test.ceu"
/* start org: guard */
#line 266 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_4)),2,Class_Halfplane,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 266 "test.ceu"
            _ceu_constr_765(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_4)), _ceu_go);

#line 266 "test.ceu"
        }
}

#line 266 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Foo_Start_cnt_128,((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->guard_4)),Class_Halfplane);
case Foo_Start_cnt_128:;
/* NODE: AwaitInt 769 */

#line 271 "test.ceu"
    _CEU_NO_769_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Foo_Awake_ok_129;

#line 271 "test.ceu"
    	return RET_HALT;
#line 271 "test.ceu"
    case Foo_Awake_ok_129:;

#line 271 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Foo*)_ceu_go->org)->guard_4) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_769_;
    }
#endif

#line 271 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: CallStmt 770 */

#line 272 "test.ceu"
    printf("Foo right preempts\n");
#line 266 "test.ceu"
    }
#line 266 "test.ceu"
/* CLEAR: Block (266) */
#line 266 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_130;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Foo_Clear_130:;

#line 266 "test.ceu"
    }
#line 266 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 265 "test.ceu"
/* PAROR JOIN */
#line 265 "test.ceu"
    _ceu_go->lbl = Foo_ParOr_out_127;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 265 "test.ceu"
case Foo_ParOr_sub_2_126:;/* NODE: Block 779 */

#line 274 "test.ceu"
    {
#line 274 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 4, (tceu_org_lnk*) &((CEU_Foo*)_ceu_go->org)->__lnks_779_4);

#line 274 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 5 ];
/* NODE: Stmts 778 */

#line 274 "test.ceu"
    {/* NODE: Stmts 1006 */

#line 274 "test.ceu"
    {/* NODE: Dcl_var 1005 */

#line 274 "test.ceu"
/* start org: default */
#line 274 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->default_5)),7,Class_Bar,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 4);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 274 "test.ceu"
        }
}

#line 274 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Foo_Start_cnt_131,((tceu_org*) (&((CEU_Foo*)_ceu_go->org)->default_5)),Class_Bar);
case Foo_Start_cnt_131:;

#line 274 "test.ceu"
    }/* NODE: AwaitInt 777 */

#line 275 "test.ceu"
    _CEU_NO_777_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Foo_Awake_ok_132;

#line 275 "test.ceu"
    	return RET_HALT;
#line 275 "test.ceu"
    case Foo_Awake_ok_132:;

#line 275 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Foo*)_ceu_go->org)->default_5) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_777_;
    }
#endif

#line 275 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 274 "test.ceu"
    }
#line 274 "test.ceu"
/* CLEAR: Block (274) */
#line 274 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_133;
}
return ceu_out_clear(_ceu_go, 4,                     &_ceu_go->org->trls[ 6 ]);

case Foo_Clear_133:;

#line 274 "test.ceu"
    }
#line 274 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 3 ]; */

#line 265 "test.ceu"
/* PAROR JOIN */
#line 265 "test.ceu"
    _ceu_go->lbl = Foo_ParOr_out_127;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 265 "test.ceu"
case Foo_ParOr_out_127:;
#line 265 "test.ceu"
/* CLEAR: ParOr (265) */
#line 265 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Foo_Clear_134;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 6 ]);

case Foo_Clear_134:;

#line 265 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 265 "test.ceu"
    }
#line 265 "test.ceu"
/* CLEAR: Block (265) */
#line 265 "test.ceu"
    }
#line 265 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}
/* NODE: EmitInt 786 */

#line 278 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Foo_EmitInt_cont_135;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_Foo*)_ceu_go->org);
#endif

#line 278 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Foo_EmitInt_cont_135:;

#line 247 "test.ceu"
    }
#line 247 "test.ceu"
/* CLEAR: Block (247) */
#line 247 "test.ceu"
    }
#line 247 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 244 "test.ceu"
    }
#line 244 "test.ceu"
/* CLEAR: Block (244) */
#line 244 "test.ceu"
    }
#line 244 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 244 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 244 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 10 */

#line 281 "test.ceu"
case Class_RulesTest:;
#line 281 "test.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 10;
#endif
/* NODE: Block 1016 */

#line 281 "test.ceu"
    {/* NODE: Stmts 1015 */

#line 281 "test.ceu"
    {/* NODE: Block 826 */

#line 284 "test.ceu"
    {/* NODE: Stmts 825 */

#line 284 "test.ceu"
    {/* NODE: CallStmt 792 */

#line 284 "test.ceu"
    printf("rulestest starting\n");/* NODE: Loop 1012 */

#line 285 "test.ceu"
    for (;;) {
/* NODE: Block 817 */

#line 286 "test.ceu"
    {/* NODE: Stmts 816 */

#line 286 "test.ceu"
    {/* NODE: CallStmt 793 */

#line 286 "test.ceu"
    printf("top of rulestest loop\n");/* NODE: If 815 */

#line 287 "test.ceu"
    if (((x()==30)&&(y()==30))) {
/* NODE: Block 807 */

#line 288 "test.ceu"
    {/* NODE: Stmts 806 */

#line 288 "test.ceu"
    {/* NODE: Break 805 */

#line 288 "test.ceu"
    break;
#line 288 "test.ceu"
    }
#line 288 "test.ceu"
/* CLEAR: Block (288) */
#line 288 "test.ceu"
    }} else {
/* NODE: Block 814 */

#line 290 "test.ceu"
    {
#line 290 "test.ceu"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_RulesTest*)_ceu_go->org)->__lnks_814_1);

#line 290 "test.ceu"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 813 */

#line 290 "test.ceu"
    {/* NODE: Stmts 1014 */

#line 290 "test.ceu"
    {/* NODE: Dcl_var 1013 */

#line 290 "test.ceu"
/* start org: body */
#line 290 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->body_2)),7,Class_Foo,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 290 "test.ceu"
        }
}

#line 290 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, RulesTest_Start_cnt_138,((tceu_org*) (&((CEU_RulesTest*)_ceu_go->org)->body_2)),Class_Foo);
case RulesTest_Start_cnt_138:;

#line 290 "test.ceu"
    }/* NODE: AwaitInt 812 */

#line 291 "test.ceu"
    _CEU_NO_812_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = RulesTest_Awake_ok_139;

#line 291 "test.ceu"
    	return RET_HALT;
#line 291 "test.ceu"
    case RulesTest_Awake_ok_139:;

#line 291 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_RulesTest*)_ceu_go->org)->body_2) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_812_;
    }
#endif

#line 291 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif

#line 290 "test.ceu"
    }
#line 290 "test.ceu"
/* CLEAR: Block (290) */
#line 290 "test.ceu"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = RulesTest_Clear_140;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case RulesTest_Clear_140:;

#line 290 "test.ceu"
    }
#line 290 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}

#line 286 "test.ceu"
    }
#line 286 "test.ceu"
/* CLEAR: Block (286) */
#line 286 "test.ceu"
    }
#line 286 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 285 "test.ceu"
    }

#line 285 "test.ceu"
/* CLEAR: Loop (285) */
#line 285 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: CallStmt 819 */

#line 294 "test.ceu"
    assert((x()==30));/* NODE: CallStmt 820 */

#line 295 "test.ceu"
    assert((y()==30));/* NODE: CallStmt 821 */

#line 296 "test.ceu"
    printf("rulestest done\n");/* NODE: EmitInt 824 */

#line 297 "test.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = RulesTest_EmitInt_cont_141;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_RulesTest*)_ceu_go->org);
#endif

#line 297 "test.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case RulesTest_EmitInt_cont_141:;

#line 284 "test.ceu"
    }
#line 284 "test.ceu"
/* CLEAR: Block (284) */
#line 284 "test.ceu"
    }
#line 284 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 281 "test.ceu"
    }
#line 281 "test.ceu"
/* CLEAR: Block (281) */
#line 281 "test.ceu"
    }
#line 281 "test.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 281 "test.ceu"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 281 "test.ceu"
    	return RET_HALT;/* NODE: Dcl_cls 11 */

#line 1 "_ceu_cpp_test.ceu.in"
case Class_Main:;
#line 1 "_ceu_cpp_test.ceu.in"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 11;
#endif
/* NODE: Block 1026 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 1025 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Nothing 853 */
/* NODE: Block 847 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 846 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Dcl_var 843 */
/* NODE: SetBlock 845 */
/* NODE: Block 841 */

#line 1 "_ceu_cpp_test.ceu.in"
    {
#line 1 "_ceu_cpp_test.ceu.in"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Main*)_ceu_go->org)->__lnks_841_1);

#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 2 ];
/* NODE: Stmts 840 */

#line 1 "_ceu_cpp_test.ceu.in"
    {/* NODE: Stmts 837 */

#line 4 "test.ceu"
    {/* NODE: Stmts 858 */

#line 4 "test.ceu"
    {/* NODE: Nothing 1029 */

#line 4 "test.ceu"
    }/* NODE: Stmts 860 */

#line 5 "test.ceu"
    {/* NODE: Nothing 1030 */

#line 5 "test.ceu"
    }/* NODE: Stmts 862 */

#line 6 "test.ceu"
    {/* NODE: Nothing 1031 */

#line 6 "test.ceu"
    }/* NODE: Stmts 864 */

#line 7 "test.ceu"
    {/* NODE: Nothing 1032 */

#line 7 "test.ceu"
    }/* NODE: Stmts 866 */

#line 8 "test.ceu"
    {/* NODE: Nothing 1033 */

#line 8 "test.ceu"
    }/* NODE: Stmts 868 */

#line 9 "test.ceu"
    {/* NODE: Nothing 1034 */

#line 9 "test.ceu"
    }/* NODE: Stmts 870 */

#line 10 "test.ceu"
    {/* NODE: Nothing 1035 */

#line 10 "test.ceu"
    }/* NODE: Stmts 872 */

#line 12 "test.ceu"
    {/* NODE: Nothing 1036 */

#line 12 "test.ceu"
    }/* NODE: Stmts 874 */

#line 13 "test.ceu"
    {/* NODE: Nothing 1037 */

#line 13 "test.ceu"
    }/* NODE: Stmts 876 */

#line 14 "test.ceu"
    {/* NODE: Nothing 1038 */

#line 14 "test.ceu"
    }/* NODE: Stmts 878 */

#line 15 "test.ceu"
    {/* NODE: Nothing 1039 */

#line 15 "test.ceu"
    }/* NODE: Nothing 1040 */
/* NODE: Nothing 1041 */
/* NODE: Nothing 1042 */
/* NODE: Nothing 1043 */
/* NODE: Nothing 1044 */
/* NODE: Nothing 1045 */
/* NODE: Nothing 1046 */
/* NODE: Nothing 1047 */
/* NODE: Nothing 1048 */
/* NODE: Nothing 1049 */
/* NODE: Nothing 1050 */
/* NODE: Nothing 1051 */
/* NODE: AwaitExt 829 */

#line 301 "test.ceu"
        _ceu_go->trl->evt = CEU_IN_START;
    _ceu_go->trl->lbl = Main_Awake_START_145;

#line 301 "test.ceu"
    	return RET_HALT;
#line 301 "test.ceu"
    case Main_Awake_START_145:;

#line 301 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Stmts 1020 */

#line 304 "test.ceu"
    {/* NODE: Dcl_var 1019 */

#line 304 "test.ceu"
/* start org: to_test */
#line 304 "test.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->to_test)),4,Class_RulesTest,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 304 "test.ceu"
        }
}

#line 304 "test.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Main_Start_cnt_146,((tceu_org*) (&((CEU_Main*)_ceu_go->org)->to_test)),Class_RulesTest);
case Main_Start_cnt_146:;

#line 304 "test.ceu"
    }/* NODE: AwaitInt 834 */

#line 305 "test.ceu"
    _CEU_NO_834_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = Main_Awake_ok_147;

#line 305 "test.ceu"
    	return RET_HALT;
#line 305 "test.ceu"
    case Main_Awake_ok_147:;

#line 305 "test.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)(&((CEU_Main*)_ceu_go->org)->to_test) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_834_;
    }
#endif

#line 305 "test.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Stmts 1024 */

#line 307 "test.ceu"
    {/* NODE: SetExp 1022 */

#line 307 "test.ceu"
/* SET: _ret */
#line 307 "test.ceu"
    ((CEU_Main*)_ceu_go->org)->_ret_0 = 0;
#line 307 "test.ceu"
    #ifdef CEU_RET
    _ceu_app->ret = ((CEU_Main*)_ceu_go->org)->_ret_0;
#endif
/* NODE: Escape 1023 */

#line 307 "test.ceu"
    _ceu_go->lbl = Main_Set_out_144;
goto _CEU_GOTO_;
/*return RET_GOTO;*/

#line 307 "test.ceu"
    }
#line 4 "test.ceu"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    	return RET_HALT;
#line 1 "_ceu_cpp_test.ceu.in"
case Main_Set_out_144:;
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: SetBlock (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_go->stki;
    trl->lbl = Main_Clear_149;
}
return ceu_out_clear(_ceu_go, 1,                     &_ceu_go->org->trls[ 3 ]);

case Main_Clear_149:;

#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];

#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_test.ceu.in"
    }
#line 1 "_ceu_cpp_test.ceu.in"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 1 "_ceu_cpp_test.ceu.in"
    #ifdef CEU_NEWS
if (_ceu_go->org->isDyn) {
    _ceu_go->org->isAlive = 0;
    return ceu_out_clear(_ceu_go, 0, _ceu_go->org);
}
#endif

#line 1 "_ceu_cpp_test.ceu.in"
    	return RET_END;
    }
    return RET_HALT;    /* TODO: should never be reached anyways */
}

static void ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
#ifdef CEU_LUA
    app->lua = luaL_newstate();
    /* TODO: lua_close(CEU_L); */
    assert(app->lua != NULL);
    luaL_openlibs(app->lua);
    lua_atpanic(app->lua, ceu_lua_atpanic);
#endif

#ifdef CEU_OS

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS */

#ifndef CEU_OS
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(app, app->data, CEU_NTRAILS, Class_Main, 0,
#ifdef CEU_NEWS
                0,
#endif
                NULL, 0);
    ceu_out_go(app, CEU_IN__INIT, CEU_EVTP((void*)NULL));
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
}
#endif
